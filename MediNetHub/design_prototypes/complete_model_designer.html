<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MediNet - Model Designer</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        /* Header y Navigation */
        .medinet-header {
            background: linear-gradient(135deg, #2563eb, #1d4ed8);
            color: white;
            padding: 0.75rem 0;
        }
        
        .nav-tabs {
            background: rgba(255,255,255,0.1);
            border-radius: 50px;
            padding: 0.5rem;
        }
        
        .nav-tabs .nav-link {
            color: rgba(255,255,255,0.7);
            border: none;
            border-radius: 40px;
            margin: 0 0.25rem;
            transition: all 0.3s ease;
        }
        
        .nav-tabs .nav-link.active {
            background: rgba(255,255,255,0.2);
            color: white;
            font-weight: 600;
        }
        
        /* Page Header */
        .page-header {
            background: white;
            border-bottom: 1px solid #e5e7eb;
            padding: 1.5rem 0;
        }
        
        .page-title {
            color: #1f2937;
            font-weight: 700;
            font-size: 1.5rem;
            margin: 0;
        }
        
        .page-subtitle {
            color: #6b7280;
            font-size: 0.875rem;
            margin: 0;
        }
        
        /* Action Buttons */
        .action-buttons {
            gap: 0.5rem;
        }
        
        .btn-action {
            border-radius: 8px;
            font-weight: 500;
            padding: 0.625rem 1.25rem;
            transition: all 0.2s ease;
            border: none;
        }
        
        .btn-action:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        
        .btn-load { background: #f3f4f6; color: #374151; }
        .btn-preview { background: #fef3c7; color: #92400e; }
        .btn-save { background: #374151; color: white; }
        .btn-training { background: #059669; color: white; }
        
        /* Main Layout */
        .designer-layout {
            display: grid;
            grid-template-columns: 320px 1fr 320px;
            gap: 1rem;
            height: calc(100vh - 180px);
            padding: 1rem;
            background: #f9fafb;
        }
        
        /* Panel Styles */
        .designer-panel {
            background: white;
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .panel-header {
            background: #f8fafc;
            border-bottom: 1px solid #e5e7eb;
            padding: 1rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        
        .panel-title {
            font-weight: 600;
            color: #1f2937;
            margin: 0;
        }
        
        .panel-icon {
            width: 20px;
            height: 20px;
            color: #6b7280;
        }
        
        .panel-body {
            flex: 1;
            padding: 1rem;
            overflow-y: auto;
        }
        
        /* Configuration Panel */
        .form-group {
            margin-bottom: 1.25rem;
        }
        
        .form-label {
            display: block;
            font-weight: 500;
            color: #374151;
            margin-bottom: 0.5rem;
            font-size: 0.875rem;
        }
        
        .form-control, .form-select {
            border: 1px solid #d1d5db;
            border-radius: 6px;
            padding: 0.5rem 0.75rem;
            font-size: 0.875rem;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }
        
        .form-control:focus, .form-select:focus {
            border-color: #2563eb;
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
            outline: none;
        }
        
        .optimizer-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.75rem;
        }
        
        /* Node Canvas - Centro del dise√±o */
        .node-canvas {
            position: relative;
            background: 
                linear-gradient(90deg, #f1f5f9 1px, transparent 1px), 
                linear-gradient(#f1f5f9 1px, transparent 1px);
            background-size: 24px 24px;
            border-radius: 8px;
            flex: 1;
            overflow: hidden;
            margin: 1rem;
            transition: background-color 0.2s ease;
        }
        
        .node-canvas.dragging-active {
            background-color: rgba(59, 130, 246, 0.02);
            background-image: 
                linear-gradient(90deg, rgba(59, 130, 246, 0.3) 1px, transparent 1px), 
                linear-gradient(rgba(59, 130, 246, 0.3) 1px, transparent 1px);
        }
        
        /* Node Styles */
        .layer-node {
            position: absolute;
            width: 150px;
            height: 80px;
            background: white;
            border-radius: 10px;
            border: 2px solid #e5e7eb;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            user-select: none;
        }
        
        .layer-node:hover {
            border-color: #3b82f6;
            transform: scale(1.02);
            z-index: 10;
            box-shadow: 0 4px 20px rgba(59, 130, 246, 0.15);
        }
        
        .layer-node.selected {
            border-color: #2563eb;
            box-shadow: 0 0 0 4px rgba(37, 99, 235, 0.15);
            z-index: 5;
        }
        
        .layer-node.dragging {
            transform: scale(1.05);
            z-index: 50;
            box-shadow: 0 12px 40px rgba(0,0,0,0.3);
            cursor: grabbing;
            opacity: 0.9;
            transition: none; /* Disable transition during drag for smoother movement */
        }
        
        .layer-node {
            cursor: grab;
        }
        
        .layer-node:active {
            cursor: grabbing;
        }
        
        /* Special styles for movable Input/Output nodes */
        .layer-node.node-input {
            border: 3px solid #3b82f6 !important;
            background: linear-gradient(145deg, #dbeafe, #bfdbfe) !important;
            box-shadow: 0 4px 20px rgba(59, 130, 246, 0.2);
        }
        
        .layer-node.node-output {
            border: 3px solid #ef4444 !important;
            background: linear-gradient(145deg, #fee2e2, #fecaca) !important;
            box-shadow: 0 4px 20px rgba(239, 68, 68, 0.2);
        }
        
        .layer-node.node-input.dragging,
        .layer-node.node-output.dragging {
            z-index: 1000;
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
            transform: scale(1.05);
        }
        
        /* Node Types */
        .layer-node.layer-input { 
            border-left: 4px solid #3b82f6; 
            background: linear-gradient(145deg, #ffffff, #f8faff);
        }
        .layer-node.layer-linear { 
            border-left: 4px solid #10b981; 
            background: linear-gradient(145deg, #ffffff, #f0fdf9);
        }
        .layer-node.layer-activation { 
            border-left: 4px solid #f59e0b; 
            background: linear-gradient(145deg, #ffffff, #fffbeb);
        }
        .layer-node.layer-output { 
            border-left: 4px solid #ef4444; 
            background: linear-gradient(145deg, #ffffff, #fef2f2);
        }
        .layer-node.layer-operation { 
            border-left: 4px solid #8b5cf6; 
            background: linear-gradient(145deg, #ffffff, #faf5ff);
        }
        
        .node-content {
            flex: 1;
            text-align: center;
        }
        
        .node-title {
            font-size: 13px;
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 3px;
        }
        
        .node-features {
            font-size: 11px;
            color: #6b7280;
        }
        
        /* Connection Ports */
        .connection-port {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            border: 2px solid #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            z-index: 20;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .connection-port:hover {
            transform: scale(1.4);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        
        .connection-port.input { 
            background: #10b981; 
        }
        .connection-port.output { 
            background: #ef4444; 
        }
        
        /* Flexible port positioning for bidirectional connections */
        .connection-port.left-side { 
            position: absolute; 
            left: -7px; 
        }
        .connection-port.right-side { 
            position: absolute; 
            right: -7px; 
        }
        
        /* Smart ports - single port per side, centered */
        .connection-port.left-side, 
        .connection-port.right-side { 
            top: 50%; 
            transform: translateY(-50%);
        }
        
        /* Smart port styling - adapts based on connection state */
        .connection-port.smart-port {
            background: #94a3b8; /* Default neutral color */
            border: 3px solid #fff;
            transition: all 0.3s ease;
        }
        
        .connection-port.smart-port:hover {
            background: #3b82f6; /* Blue when hovering */
            transform: translateY(-50%) scale(1.4);
        }
        
        .connection-port.smart-port.acting-as-input {
            background: #10b981; /* Green when acting as input */
        }
        
        .connection-port.smart-port.acting-as-output {
            background: #ef4444; /* Red when acting as output */
        }
        
        .connection-port.smart-port.connecting {
            background: #3b82f6 !important; /* Blue when connecting */
            border-color: #1d4ed8;
            animation: pulse-connect 1s infinite;
        }
        
        /* Traditional inline positioning (default) */
        .connection-port:not(.left-side):not(.right-side).input { margin-right: 10px; }
        .connection-port:not(.left-side):not(.right-side).output { margin-left: 10px; }
        
        /* Port States */
        .connection-port.disconnected {
            background: #94a3b8 !important;
            border-color: #cbd5e1;
            animation: pulse-disconnect 2s infinite;
        }
        
        .connection-port.connecting {
            background: #3b82f6 !important;
            border-color: #1d4ed8;
            animation: pulse-connect 1s infinite;
            transform: scale(1.3);
        }
        
        @keyframes pulse-disconnect {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        @keyframes pulse-connect {
            0%, 100% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.7); }
            50% { box-shadow: 0 0 0 6px rgba(59, 130, 246, 0); }
        }
        
        /* SVG Connections */
        .connection-path {
            stroke: #6b7280;
            stroke-width: 2.5;
            fill: none;
            stroke-dasharray: 8, 4;
            animation: dash-flow 3s linear infinite;
            filter: drop-shadow(0 1px 2px rgba(0,0,0,0.1));
            cursor: pointer;
            pointer-events: all;
            transition: all 0.2s ease;
        }
        
        .connection-path.flow-highlight {
            stroke: #3b82f6;
            stroke-width: 3.5;
            stroke-dasharray: 12, 6;
            filter: drop-shadow(0 2px 8px rgba(59, 130, 246, 0.4));
            animation: flow-highlight 2s linear infinite;
        }
        
        @keyframes flow-highlight {
            0% { stroke-dashoffset: 0; }
            100% { stroke-dashoffset: -18; }
        }
        
        .connection-path:hover {
            stroke: #ef4444;
            stroke-width: 4;
            stroke-dasharray: none;
            animation: none;
            filter: drop-shadow(0 2px 8px rgba(239, 68, 68, 0.3));
        }
        
        .connection-path.deleting {
            stroke: #dc2626;
            stroke-width: 5;
            stroke-dasharray: 4, 4;
            animation: delete-pulse 0.5s ease-in-out infinite alternate;
        }
        
        .connection-path.connection-selected {
            stroke: #fbbf24 !important;
            stroke-width: 4;
            filter: drop-shadow(0 2px 8px rgba(251, 191, 36, 0.5));
            animation: none;
        }
        
        @keyframes dash-flow {
            to { stroke-dashoffset: -12; }
        }
        
        @keyframes delete-pulse {
            from { opacity: 1; }
            to { opacity: 0.3; }
        }
        
        /* Preview Connection Line */
        .connection-preview {
            stroke: #3b82f6;
            stroke-width: 3;
            fill: none;
            stroke-dasharray: 8, 8;
            animation: preview-flow 1s linear infinite;
            opacity: 0.8;
            pointer-events: none;
        }
        
        @keyframes preview-flow {
            to { stroke-dashoffset: 16; }
        }
        
        /* Curve Editing System */
        .connection-editing {
            stroke: #8b5cf6 !important;
            stroke-width: 4 !important;
            stroke-dasharray: none !important;
            animation: none !important;
            filter: drop-shadow(0 2px 8px rgba(139, 92, 246, 0.3));
        }
        
        .curve-control-point {
            fill: #ffffff;
            stroke: #8b5cf6;
            stroke-width: 2;
            cursor: grab;
            r: 6;
            transition: all 0.2s ease;
        }
        
        .curve-control-point:hover {
            r: 8;
            fill: #8b5cf6;
            cursor: grabbing;
        }
        
        .curve-control-point.dragging {
            fill: #8b5cf6;
            stroke-width: 3;
            cursor: grabbing;
        }
        
        .curve-control-line {
            stroke: #8b5cf6;
            stroke-width: 1;
            stroke-dasharray: 4, 4;
            opacity: 0.6;
        }
        
        .curve-edit-ui {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 8px;
            padding: 8px 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            display: none;
            z-index: 100;
        }
        
        .curve-edit-ui.active {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        
        .curve-edit-btn {
            background: none;
            border: 1px solid #e5e7eb;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .curve-edit-btn:hover {
            background: #f3f4f6;
        }
        
        .curve-edit-btn.save {
            background: #10b981;
            color: white;
            border-color: #10b981;
        }
        
        .curve-edit-btn.cancel {
            background: #ef4444;
            color: white;
            border-color: #ef4444;
        }
        
        /* Add Node Button */
        .add-node-btn {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            border: 2px dashed #cbd5e1;
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            color: #64748b;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        
        .add-node-btn:hover {
            border-color: #3b82f6;
            color: #3b82f6;
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(59, 130, 246, 0.15);
        }
        
        /* Layer Parameters Panel */
        .param-section {
            margin-bottom: 1.5rem;
        }
        
        .param-section-title {
            font-size: 0.875rem;
            font-weight: 600;
            color: #374151;
            margin-bottom: 0.75rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid #f3f4f6;
        }
        
        .param-row {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 0.75rem;
        }
        
        .param-row label {
            min-width: 80px;
            font-size: 0.8125rem;
            color: #6b7280;
        }
        
        .param-row input {
            flex: 1;
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
        }
        
        .delete-btn {
            width: 100%;
            background: #fee2e2;
            color: #dc2626;
            border: 1px solid #fecaca;
            border-radius: 6px;
            padding: 0.5rem;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .delete-btn:hover {
            background: #fecaca;
            border-color: #fca5a5;
        }
        
        /* Node Positions */
        .node-1 { top: 30px; left: 30px; }
        .node-2 { top: 30px; left: 220px; }
        .node-3 { top: 30px; left: 410px; }
        .node-4 { top: 140px; left: 220px; }
        .node-5 { top: 140px; left: 410px; }
        
        /* Responsive Design */
        @media (max-width: 1200px) {
            .designer-layout {
                grid-template-columns: 280px 1fr 280px;
            }
        }
        
        @media (max-width: 992px) {
            .designer-layout {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto 1fr;
                height: auto;
            }
            
            .designer-panel {
                max-height: 400px;
            }
            
            .node-canvas {
                min-height: 400px;
            }
        }
        
        /* Status Indicators */
        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 0.5rem;
        }
        
        .status-active { background: #10b981; }
        .status-inactive { background: #6b7280; }
        .status-error { background: #ef4444; }
    </style>
</head>
<body>
    <!-- Header Navigation -->
    <header class="medinet-header">
        <div class="container">
            <div class="d-flex justify-content-between align-items-center">
                <div class="d-flex align-items-center">
                    <h4 class="text-white mb-0 me-4">
                        <i class="fas fa-brain me-2"></i>
                        MediNet
                    </h4>
                    
                    <ul class="nav nav-tabs border-0">
                        <li class="nav-item">
                            <a class="nav-link" href="#">
                                <i class="fas fa-database me-1"></i>
                                Panel
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="#">
                                <i class="fas fa-chart-bar me-1"></i>
                                Datasets
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link active" href="#">
                                <i class="fas fa-project-diagram me-1"></i>
                                Model Studio
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="#">
                                <i class="fas fa-cogs me-1"></i>
                                Training
                            </a>
                        </li>
                    </ul>
                </div>
                
                <div class="d-flex align-items-center text-white">
                    <i class="fas fa-bell me-3"></i>
                    <div class="dropdown">
                        <span class="dropdown-toggle" data-bs-toggle="dropdown">
                            <i class="fas fa-user-circle me-1"></i>
                            admin
                        </span>
                    </div>
                </div>
            </div>
        </div>
    </header>

    <!-- Page Header -->
    <div class="page-header">
        <div class="container">
            <div class="row align-items-center">
                <div class="col-md-6">
                    <h1 class="page-title">
                        <i class="fas fa-project-diagram me-2 text-primary"></i>
                        Model Designer
                    </h1>
                    <p class="page-subtitle">
                        Design neural network architectures for federated training
                    </p>
                </div>
                <div class="col-md-6">
                    <div class="d-flex justify-content-md-end action-buttons">
                        <button class="btn btn-action btn-load">
                            <i class="fas fa-folder-open me-1"></i>
                            Load Model
                        </button>
                        <button class="btn btn-action btn-preview">
                            <i class="fas fa-code me-1"></i>
                            Preview JSON
                        </button>
                        <button class="btn btn-action btn-save">
                            <i class="fas fa-save me-1"></i>
                            Save Model
                        </button>
                        <button class="btn btn-action btn-training">
                            <i class="fas fa-play me-1"></i>
                            Go to Training
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Designer Layout -->
    <div class="designer-layout">
        <!-- Configuration Panel (Left) -->
        <div class="designer-panel">
            <div class="panel-header">
                <i class="fas fa-cog panel-icon"></i>
                <h6 class="panel-title">Configuration</h6>
            </div>
            <div class="panel-body">
                <!-- Model Basic Info -->
                <div class="form-group">
                    <label class="form-label">Model Name</label>
                    <input type="text" class="form-control" value="My Neural Network" placeholder="Enter model name">
                </div>
                
                <div class="form-group">
                    <label class="form-label">Framework</label>
                    <select class="form-select">
                        <option selected>PyTorch</option>
                        <option>TensorFlow</option>
                        <option>Keras</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label class="form-label">Description</label>
                    <textarea class="form-control" rows="3" placeholder="Model description..."></textarea>
                </div>
                
                <!-- Optimizer Configuration -->
                <div class="form-group">
                    <label class="form-label">Optimizer</label>
                    <select class="form-select">
                        <option selected>Adam</option>
                        <option>SGD</option>
                        <option>RMSprop</option>
                        <option>AdaGrad</option>
                    </select>
                </div>
                
                <div class="optimizer-grid">
                    <div>
                        <label class="form-label">Learning Rate</label>
                        <input type="number" class="form-control" value="0.001" step="0.0001">
                    </div>
                    <div>
                        <label class="form-label">Weight Decay</label>
                        <input type="number" class="form-control" value="0" step="0.0001">
                    </div>
                </div>
                
                <!-- Loss Function -->
                <div class="form-group">
                    <label class="form-label">Loss Function</label>
                    <select class="form-select">
                        <option selected>Binary Cross Entropy with Logits</option>
                        <option>Cross Entropy</option>
                        <option>Mean Squared Error</option>
                        <option>Mean Absolute Error</option>
                    </select>
                </div>
                
                <!-- Model Status -->
                <div class="mt-4 p-3 bg-light rounded">
                    <h6 class="mb-2">Model Status</h6>
                    <div class="d-flex align-items-center mb-2">
                        <span class="status-indicator status-active"></span>
                        <small>Ready for training</small>
                    </div>
                    <div class="d-flex justify-content-between">
                        <small class="text-muted">Layers: 5</small>
                        <small class="text-muted">Parameters: ~2.1K</small>
                    </div>
                </div>
            </div>
        </div>

        <!-- Node Canvas (Center) -->
        <div class="designer-panel">
            <div class="panel-header">
                <i class="fas fa-sitemap panel-icon"></i>
                <h6 class="panel-title">Neural Network Graph</h6>
                <div class="ms-auto">
                    <button class="btn btn-sm btn-outline-primary me-2">
                        <i class="fas fa-magic me-1"></i>
                        Auto Layout
                    </button>
                    <button class="btn btn-sm btn-outline-secondary">
                        <i class="fas fa-undo me-1"></i>
                        Reset View
                    </button>
                </div>
            </div>
            
            <div class="node-canvas" id="nodeCanvas">
                <!-- SVG for Connections -->
                <svg id="connectionsSvg" style="position: absolute; width: 100%; height: 100%; z-index: 1; pointer-events: none;">
                    <!-- Connections will be drawn dynamically -->
                </svg>
                
                <!-- Input Node (Now Movable) -->
                <div class="layer-node layer-input node-input selected" data-node-id="input" style="top: 50%; left: 50px; transform: translateY(-50%);">
                    <div class="node-content">
                        <div class="node-title">Input</div>
                        <div class="node-features">12 features</div>
                    </div>
                    <div class="connection-port smart-port right-side acting-as-output" 
                         data-port-type="output" data-side="right" data-preferred="output"></div>
                </div>
                
                <!-- Output Node (Now Movable) -->
                <div class="layer-node layer-output node-output" data-node-id="output" style="top: 50%; right: 50px; transform: translateY(-50%);">
                    <div class="connection-port smart-port left-side acting-as-input" 
                         data-port-type="input" data-side="left" data-preferred="input"></div>
                    <div class="node-content">
                        <div class="node-title">Output</div>
                        <div class="node-features">1 feature</div>
                    </div>
                </div>
                
                <!-- Add Layer Button -->
                <div class="add-node-btn" id="addLayerBtn" data-bs-toggle="tooltip" title="Add Layer">
                    <i class="fas fa-plus fa-lg"></i>
                </div>
                
                <!-- Connection Helper Line (Hidden by default) -->
                <svg id="connectionHelper" style="position: absolute; width: 100%; height: 100%; z-index: 15; pointer-events: none; display: none;">
                    <path id="helperPath" stroke="#3b82f6" stroke-width="3" fill="none" stroke-dasharray="5,5" opacity="0.7"/>
                </svg>
                
                <!-- Curve Editing UI -->
                <div id="curveEditUI" class="curve-edit-ui">
                    <span style="font-size: 12px; color: #6b7280; margin-right: 8px;">
                        <i class="fas fa-edit"></i>
                        Edit Curve
                    </span>
                    <button class="curve-edit-btn save" id="saveCurveBtn">
                        <i class="fas fa-check"></i>
                        Save
                    </button>
                    <button class="curve-edit-btn cancel" id="cancelCurveBtn">
                        <i class="fas fa-times"></i>
                        Cancel
                    </button>
                    <small style="color: #9ca3af; margin-left: 8px;">
                        Drag control points to adjust curve
                    </small>
                </div>
            </div>
        </div>

        <!-- Layer Parameters Panel (Right) -->
        <div class="designer-panel">
            <div class="panel-header">
                <i class="fas fa-sliders-h panel-icon"></i>
                <h6 class="panel-title">Layer Parameters</h6>
            </div>
            <div class="panel-body">
                <div class="param-section">
                    <div class="param-section-title">Linear Parameters</div>
                    
                    <div class="param-row">
                        <label>In Features</label>
                        <input type="number" class="form-control" value="64">
                    </div>
                    
                    <div class="param-row">
                        <label>Out Features</label>
                        <input type="number" class="form-control" value="64">
                    </div>
                    
                    <div class="checkbox-group">
                        <input type="checkbox" id="use-bias" checked>
                        <label for="use-bias" class="form-check-label">
                            Use Bias
                        </label>
                    </div>
                </div>
                
                <div class="param-section">
                    <div class="param-section-title">Advanced Settings</div>
                    
                    <div class="param-row">
                        <label>Device</label>
                        <select class="form-select form-select-sm">
                            <option>Auto</option>
                            <option>CPU</option>
                            <option>CUDA</option>
                        </select>
                    </div>
                    
                    <div class="param-row">
                        <label>Dtype</label>
                        <select class="form-select form-select-sm">
                            <option>float32</option>
                            <option>float16</option>
                            <option>float64</option>
                        </select>
                    </div>
                </div>
                
                <div class="param-section">
                    <div class="param-section-title">Initialization</div>
                    
                    <div class="param-row">
                        <label>Weight Init</label>
                        <select class="form-select form-select-sm">
                            <option>Xavier Uniform</option>
                            <option>Xavier Normal</option>
                            <option>He Uniform</option>
                            <option>He Normal</option>
                            <option>Random</option>
                        </select>
                    </div>
                    
                    <div class="param-row">
                        <label>Bias Init</label>
                        <select class="form-select form-select-sm">
                            <option>Zero</option>
                            <option>Random</option>
                            <option>Constant</option>
                        </select>
                    </div>
                </div>
                
                <!-- Action Buttons -->
                <div class="mt-4">
                    <button class="btn btn-primary btn-sm w-100 mb-2">
                        <i class="fas fa-check me-1"></i>
                        Apply Changes
                    </button>
                    <button class="delete-btn" id="deleteNodeBtn">
                        <i class="fas fa-trash me-1"></i>
                        Delete Layer
                    </button>
                </div>
                
                <!-- Layer Info -->
                <div class="mt-4 p-3 bg-light rounded">
                    <h6 class="mb-2">Layer Information</h6>
                    <div class="d-flex justify-content-between mb-1">
                        <small class="text-muted">Parameters:</small>
                        <small>4,160</small>
                    </div>
                    <div class="d-flex justify-content-between mb-1">
                        <small class="text-muted">Memory:</small>
                        <small>~16.6 KB</small>
                    </div>
                    <div class="d-flex justify-content-between">
                        <small class="text-muted">FLOPs:</small>
                        <small>4,096</small>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    
    <script>
        // Model Designer State
        let nodes = new Map();
        let connections = new Map();
        let nodeCounter = 0;
        let isConnecting = false;
        let connectingFrom = null;
        let isDragging = false;
        let dragNode = null;
        let dragOffset = { x: 0, y: 0 };
        
        // Curve editing state
        let isEditingCurve = false;
        let editingConnection = null;
        let editingPath = null;
        let controlPoints = [];
        let isDraggingControlPoint = false;
        let dragControlPoint = null;
        
        // Grid settings
        const GRID_SIZE = 24;
        const SNAP_THRESHOLD = 12;
        
        // Layer Types Configuration
        const layerTypes = {
            linear: { name: 'Linear', color: '#10b981', defaultFeatures: 64 },
            relu: { name: 'ReLU', color: '#f59e0b', defaultFeatures: 'same' },
            sigmoid: { name: 'Sigmoid', color: '#f59e0b', defaultFeatures: 'same' },
            tanh: { name: 'Tanh', color: '#f59e0b', defaultFeatures: 'same' },
            dropout: { name: 'Dropout', color: '#8b5cf6', defaultFeatures: 'same' },
            batchnorm: { name: 'BatchNorm', color: '#6366f1', defaultFeatures: 'same' },
            conv2d: { name: 'Conv2D', color: '#06b6d4', defaultFeatures: 32 }
        };

        // Initialize tooltips
        const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'))
        const tooltipList = tooltipTriggerList.map(function (tooltipTriggerEl) {
            return new bootstrap.Tooltip(tooltipTriggerEl)
        })
        
        // Initialize canvas
        function initializeCanvas() {
            // Set initial port states as disconnected
            document.querySelectorAll('.connection-port').forEach(port => {
                port.classList.add('disconnected');
            });
            
            console.log('üé® Canvas initialized with Input and Output nodes disconnected');
        }
        
        // Node selection functionality
        document.addEventListener('click', function(e) {
            if (e.target.closest('.layer-node')) {
                const node = e.target.closest('.layer-node');
                // Remove selected class from all nodes
                document.querySelectorAll('.layer-node').forEach(n => n.classList.remove('selected'));
                // Add selected class to clicked node
                node.classList.add('selected');
                
                updateParametersPanel(node);
                console.log('üéØ Node selected:', node.querySelector('.node-title').textContent);
            }
        });
        
        // Consolidated mousedown handler for all interactions
        document.addEventListener('mousedown', function(e) {
            // Priority 1: Smart connection ports (highest priority)
            const port = e.target.closest('.connection-port');
            if (port && !isDragging) {
                // üî• NEW: Smart port logic - any port can start connection
                if (port.classList.contains('smart-port') || port.classList.contains('output')) {
                    startConnectionPreview(e, port);
                    console.log('üéØ Starting connection from smart/output port');
                } else if (port.classList.contains('input') && !port.classList.contains('smart-port')) {
                    console.log('‚ö†Ô∏è Cannot start connection - port is input-only (use smart ports for flexibility)');
                }
                e.preventDefault();
                return;
            }
            
            // Priority 2: Node dragging (including Input/Output - only if not clicking on connection port)
            const node = e.target.closest('.layer-node');
            if (node && !e.target.closest('.connection-port') && !isConnecting) {
                startDragging(e, node);
                console.log('üéØ Started dragging node:', node.dataset.nodeId);
            }
        });
        
        document.addEventListener('mousemove', function(e) {
            if (isConnecting && connectingFrom) {
                updateConnectionPreview(e);
            } else if (isDragging && dragNode) {
                updateDragging(e);
            } else if (isDraggingControlPoint) {
                updateControlPointDrag(e);
            }
        });
        
        document.addEventListener('mouseup', function(e) {
            if (isConnecting) {
                const port = e.target.closest('.connection-port');
                // üî• NEW: Smart ports can act as input, or fixed input ports
                if (port && (port.classList.contains('smart-port') || port.classList.contains('input'))) {
                    completeConnectionFromPreview(port);
                    console.log('‚úÖ Connection completed to smart/input port');
                } else {
                    console.log('‚ö†Ô∏è Cannot complete connection - target port cannot act as input');
                    cancelConnectionPreview();
                }
            } else if (isDragging) {
                stopDragging();
            } else if (isDraggingControlPoint) {
                stopControlPointDrag();
            }
        });
        
        // Fix double-click connection issue with smart timing
        let connectionClickTimer = null;
        let clickedConnection = null;
        
        document.addEventListener('click', function(e) {
            if (e.target.classList.contains('connection-path')) {
                // Delay single click to allow double-click detection
                clickedConnection = e.target;
                connectionClickTimer = setTimeout(() => {
                    // Only process if we didn't get a double-click
                    if (clickedConnection) {
                        if (e.ctrlKey || e.metaKey) {
                            console.log('üóëÔ∏è Ctrl+Click - Delete connection');
                            handleConnectionClick(clickedConnection);
                        } else {
                            console.log('üéØ Single click - Select connection');
                            // üî• FIX: Select connection instead of deleting
                            selectConnection(clickedConnection);
                        }
                        clickedConnection = null;
                    }
                }, 300); // Wait 300ms for potential double-click
            }
        });
        
        document.addEventListener('dblclick', function(e) {
            if (e.target.classList.contains('connection-path')) {
                // Cancel single-click timer
                if (connectionClickTimer) {
                    clearTimeout(connectionClickTimer);
                    connectionClickTimer = null;
                }
                clickedConnection = null;
                console.log('üìê Double click - Edit curve');
                
                // üî• FIX: Clear any existing selections first
                document.querySelectorAll('.connection-path').forEach(path => {
                    path.classList.remove('connection-selected');
                });
                document.querySelectorAll('.layer-node').forEach(node => {
                    node.classList.remove('selected');
                });
                
                // Start curve editing
                startCurveEditing(e.target);
            }
        });
        
        // Consolidated mousedown handler moved above
        
        // üî• NEW: Smart Port Intelligence System
        function determineSmartPortRole(port, role) {
            const isSmart = port.classList.contains('smart-port');
            if (!isSmart) return role; // Fixed ports keep their role
            
            const preferred = port.dataset.preferred;
            const side = port.dataset.side;
            
            // For smart ports, check if role matches preference
            if (role === preferred) {
                port.classList.add(`acting-as-${role}`);
                port.classList.remove(`acting-as-${role === 'input' ? 'output' : 'input'}`);
                port.dataset.portType = role;
                console.log(`üß† Smart port (${side}) adapting as ${role.toUpperCase()}`);
                return role;
            } else {
                // Allow flexibility - smart ports can act against preference if needed
                port.classList.add(`acting-as-${role}`);
                port.classList.remove(`acting-as-${role === 'input' ? 'output' : 'input'}`);
                port.dataset.portType = role;
                console.log(`üîÑ Smart port (${side}) flexibly acting as ${role.toUpperCase()} (against preference: ${preferred})`);
                return role;
            }
        }
        
        // New Connection Preview System
        function startConnectionPreview(e, port) {
            const nodeId = port.closest('.layer-node').dataset.nodeId;
            
            // üî• NEW: Smart port determines its role as OUTPUT when starting connection
            const actualRole = determineSmartPortRole(port, 'output');
            
            isConnecting = true;
            connectingFrom = { 
                port, 
                nodeId, 
                portType: 'output',
                startX: e.clientX,
                startY: e.clientY
            };
            
            port.classList.add('connecting');
            
            // Show connection helper SVG
            const helperSvg = document.getElementById('connectionHelper');
            helperSvg.style.display = 'block';
            
            console.log('üîó Started connection preview from:', nodeId);
        }
        
        function updateConnectionPreview(e) {
            if (!isConnecting || !connectingFrom) return;
            
            const canvasRect = document.getElementById('nodeCanvas').getBoundingClientRect();
            const fromRect = connectingFrom.port.getBoundingClientRect();
            
            // Calculate positions relative to canvas
            const fromX = fromRect.left - canvasRect.left + fromRect.width / 2;
            const fromY = fromRect.top - canvasRect.top + fromRect.height / 2;
            const toX = e.clientX - canvasRect.left;
            const toY = e.clientY - canvasRect.top;
            
            // Update preview path
            const helperPath = document.getElementById('helperPath');
            const midX = (fromX + toX) / 2;
            const pathData = `M ${fromX} ${fromY} Q ${midX} ${fromY}, ${midX} ${(fromY + toY) / 2} Q ${midX} ${toY}, ${toX} ${toY}`;
            
            helperPath.setAttribute('d', pathData);
            helperPath.setAttribute('class', 'connection-preview');
        }
        
        function completeConnectionFromPreview(toPort) {
            const fromPort = connectingFrom.port;
            const fromNodeId = connectingFrom.nodeId;
            const toNodeId = toPort.closest('.layer-node').dataset.nodeId;
            
            // üî• NEW: Smart port determines its role as INPUT when completing connection
            const actualToRole = determineSmartPortRole(toPort, 'input');
            
            // Create connection
            const connectionId = `${fromNodeId}-${toNodeId}`;
            connections.set(connectionId, {
                from: fromNodeId,
                to: toNodeId,
                fromPort,
                toPort
            });
            
            // Update port states
            fromPort.classList.remove('connecting', 'disconnected');
            toPort.classList.remove('disconnected');
            
            // Draw connection line
            drawConnection(fromPort, toPort, connectionId);
            
            // Hide preview
            document.getElementById('connectionHelper').style.display = 'none';
            
            // üî• NEW: Update flow highlighting to show data flow
            setTimeout(() => updateFlowHighlighting(), 100);
            
            console.log('‚úÖ Connection created from preview:', fromNodeId, '‚Üí', toNodeId);
            
            // Reset connection state
            isConnecting = false;
            connectingFrom = null;
        }
        
        function cancelConnectionPreview() {
            if (connectingFrom) {
                connectingFrom.port.classList.remove('connecting');
                connectingFrom.port.classList.add('disconnected');
            }
            
            // Hide preview
            document.getElementById('connectionHelper').style.display = 'none';
            
            isConnecting = false;
            connectingFrom = null;
            console.log('‚ùå Connection preview cancelled');
        }
        
        // Curve Editing System
        function startCurveEditing(pathElement) {
            if (isEditingCurve) return; // Prevent multiple editing sessions
            
            const connectionId = pathElement.dataset.connectionId;
            if (!connections.has(connectionId)) return;
            
            isEditingCurve = true;
            editingConnection = connections.get(connectionId);
            editingPath = pathElement;
            
            // Highlight the path being edited
            pathElement.classList.add('connection-editing');
            
            // Create control points
            createControlPoints(pathElement);
            
            // Show editing UI
            document.getElementById('curveEditUI').classList.add('active');
            
            console.log('üìê Started curve editing for connection:', connectionId);
        }
        
        function createControlPoints(pathElement) {
            const svg = document.getElementById('connectionsSvg');
            const pathData = pathElement.getAttribute('d');
            
            // Parse the current path to extract control points
            const pathParts = pathData.match(/M ([\d.]+) ([\d.]+) Q ([\d.]+) ([\d.]+), ([\d.]+) ([\d.]+) Q ([\d.]+) ([\d.]+), ([\d.]+) ([\d.]+)/);
            
            if (!pathParts) return;
            
            const startX = parseFloat(pathParts[1]);
            const startY = parseFloat(pathParts[2]);
            const cp1X = parseFloat(pathParts[3]);
            const cp1Y = parseFloat(pathParts[4]);
            const midX = parseFloat(pathParts[5]);
            const midY = parseFloat(pathParts[6]);
            const cp2X = parseFloat(pathParts[7]);
            const cp2Y = parseFloat(pathParts[8]);
            const endX = parseFloat(pathParts[9]);
            const endY = parseFloat(pathParts[10]);
            
            // üî• FIX: Create control points with proper attributes
            const controlPoint1 = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            controlPoint1.setAttribute('cx', midX);
            controlPoint1.setAttribute('cy', cp1Y);
            controlPoint1.setAttribute('r', '8');
            controlPoint1.setAttribute('class', 'curve-control-point');
            controlPoint1.dataset.controlType = 'cp1';
            controlPoint1.style.cursor = 'grab';
            
            const controlPoint2 = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            controlPoint2.setAttribute('cx', midX);
            controlPoint2.setAttribute('cy', cp2Y);
            controlPoint2.setAttribute('class', 'curve-control-point');
            controlPoint2.dataset.controlType = 'cp2';
            
            // Create control lines (visual helpers)
            const controlLine1 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            controlLine1.setAttribute('x1', startX);
            controlLine1.setAttribute('y1', startY);
            controlLine1.setAttribute('x2', midX);
            controlLine1.setAttribute('y2', cp1Y);
            controlLine1.setAttribute('class', 'curve-control-line');
            
            const controlLine2 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            controlLine2.setAttribute('x1', endX);
            controlLine2.setAttribute('y1', endY);
            controlLine2.setAttribute('x2', midX);
            controlLine2.setAttribute('y2', cp2Y);
            controlLine2.setAttribute('class', 'curve-control-line');
            
            svg.appendChild(controlLine1);
            svg.appendChild(controlLine2);
            svg.appendChild(controlPoint1);
            svg.appendChild(controlPoint2);
            
            controlPoints = [
                { element: controlPoint1, line: controlLine1, type: 'cp1' },
                { element: controlPoint2, line: controlLine2, type: 'cp2' }
            ];
            
            // Add drag listeners to control points
            controlPoints.forEach(cp => {
                cp.element.addEventListener('mousedown', (e) => startControlPointDrag(e, cp));
            });
        }
        
        function startControlPointDrag(e, controlPoint) {
            isDraggingControlPoint = true;
            dragControlPoint = controlPoint;
            
            controlPoint.element.classList.add('dragging');
            e.stopPropagation();
            e.preventDefault();
            
            console.log('üéõÔ∏è Started dragging control point:', controlPoint.type);
        }
        
        function updateControlPointDrag(e) {
            if (!isDraggingControlPoint || !dragControlPoint) return;
            
            const canvasRect = document.getElementById('nodeCanvas').getBoundingClientRect();
            const x = e.clientX - canvasRect.left;
            const y = e.clientY - canvasRect.top;
            
            // üî• FIX: Update control point position
            dragControlPoint.element.setAttribute('cx', x);
            dragControlPoint.element.setAttribute('cy', y);
            
            // üî• FIX: Update control line endpoints properly
            dragControlPoint.line.setAttribute('x2', x);
            dragControlPoint.line.setAttribute('y2', y);
            
            // üî• FIX: Update the curve path immediately
            updateCurvePath();
            
            console.log(`üéõÔ∏è Dragging control point to (${x}, ${y})`);
        }
        
        function stopControlPointDrag() {
            if (isDraggingControlPoint && dragControlPoint) {
                dragControlPoint.element.classList.remove('dragging');
                console.log('üéõÔ∏è Stopped dragging control point:', dragControlPoint.type);
            }
            
            isDraggingControlPoint = false;
            dragControlPoint = null;
        }
        
        function updateCurvePath() {
            if (!editingPath || controlPoints.length !== 2) {
                console.log('‚ö†Ô∏è Cannot update curve - missing path or control points');
                return;
            }
            
            const pathData = editingPath.getAttribute('d');
            const pathParts = pathData.match(/M ([\d.]+) ([\d.]+) Q ([\d.]+) ([\d.]+), ([\d.]+) ([\d.]+) Q ([\d.]+) ([\d.]+), ([\d.]+) ([\d.]+)/);
            
            if (!pathParts) {
                console.log('‚ö†Ô∏è Cannot parse path data:', pathData);
                return;
            }
            
            const startX = parseFloat(pathParts[1]);
            const startY = parseFloat(pathParts[2]);
            const midX = parseFloat(pathParts[5]);
            const midY = parseFloat(pathParts[6]);
            const endX = parseFloat(pathParts[9]);
            const endY = parseFloat(pathParts[10]);
            
            // üî• FIX: Get current control point positions
            const cp1X = parseFloat(controlPoints[0].element.getAttribute('cx'));
            const cp1Y = parseFloat(controlPoints[0].element.getAttribute('cy'));
            const cp2X = parseFloat(controlPoints[1].element.getAttribute('cx'));
            const cp2Y = parseFloat(controlPoints[1].element.getAttribute('cy'));
            
            // üî• FIX: Create new path using actual control points
            const newPathData = `M ${startX} ${startY} Q ${cp1X} ${cp1Y}, ${midX} ${midY} Q ${cp2X} ${cp2Y}, ${endX} ${endY}`;
            editingPath.setAttribute('d', newPathData);
            
            console.log('üîÑ Updated curve path:', { cp1X, cp1Y, cp2X, cp2Y });
        }
        
        function saveCurveEdit() {
            if (!isEditingCurve) return;
            
            // Clean up control points and lines
            cleanupCurveEditor();
            
            // Remove editing highlight
            editingPath.classList.remove('connection-editing');
            
            console.log('üíæ Curve edit saved');
            resetCurveEditor();
        }
        
        function cancelCurveEdit() {
            if (!isEditingCurve) return;
            
            // Restore original path (we should store this when starting edit)
            // For now, just redraw the connection
            if (editingConnection) {
                editingPath.remove();
                drawConnection(editingConnection.fromPort, editingConnection.toPort, 
                              Object.keys(connections.entries()).find(key => connections.get(key) === editingConnection));
            }
            
            cleanupCurveEditor();
            console.log('‚ùå Curve edit cancelled');
            resetCurveEditor();
        }
        
        function cleanupCurveEditor() {
            // Remove control points and lines
            controlPoints.forEach(cp => {
                cp.element.remove();
                cp.line.remove();
            });
            controlPoints = [];
        }
        
        function resetCurveEditor() {
            isEditingCurve = false;
            editingConnection = null;
            editingPath = null;
            
            // Hide editing UI
            document.getElementById('curveEditUI').classList.remove('active');
        }
        
        function drawConnection(fromPort, toPort, connectionId = null) {
            const svg = document.getElementById('connectionsSvg');
            const fromRect = fromPort.getBoundingClientRect();
            const toRect = toPort.getBoundingClientRect();
            const canvasRect = document.getElementById('nodeCanvas').getBoundingClientRect();
            
            // Calculate relative positions
            const fromX = fromRect.left - canvasRect.left + fromRect.width / 2;
            const fromY = fromRect.top - canvasRect.top + fromRect.height / 2;
            const toX = toRect.left - canvasRect.left + toRect.width / 2;
            const toY = toRect.top - canvasRect.top + toRect.height / 2;
            
            // Create path element
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            const midX = (fromX + toX) / 2;
            const pathData = `M ${fromX} ${fromY} Q ${midX} ${fromY}, ${midX} ${(fromY + toY) / 2} Q ${midX} ${toY}, ${toX} ${toY}`;
            
            path.setAttribute('d', pathData);
            path.setAttribute('class', 'connection-path');
            if (connectionId) {
                path.dataset.connectionId = connectionId;
            }
            
            svg.appendChild(path);
            return path;
        }
        
        // üî• FIX: Connection selection system
        function selectConnection(pathElement) {
            // Clear all previous selections
            document.querySelectorAll('.connection-path').forEach(path => {
                path.classList.remove('connection-selected');
            });
            document.querySelectorAll('.layer-node').forEach(node => {
                node.classList.remove('selected');
            });
            
            // Select this connection
            pathElement.classList.add('connection-selected');
            console.log('‚úÖ Connection selected:', pathElement.dataset.connectionId);
        }
        
        // üî• NEW: Flow highlighting system - shows data flow from Input
        function updateFlowHighlighting() {
            // Remove existing highlights
            document.querySelectorAll('.connection-path').forEach(path => {
                path.classList.remove('flow-highlight');
            });
            
            // Find all paths from Input node
            const inputNodeId = 'input';
            const flowPaths = new Set();
            
            function traceFlowFromNode(nodeId, visited = new Set()) {
                if (visited.has(nodeId)) return; // Avoid cycles
                visited.add(nodeId);
                
                connections.forEach((connection, connectionId) => {
                    if (connection.from === nodeId) {
                        flowPaths.add(connectionId);
                        traceFlowFromNode(connection.to, visited);
                    }
                });
            }
            
            traceFlowFromNode(inputNodeId);
            
            // Apply highlighting to flow paths
            flowPaths.forEach(connectionId => {
                const pathElement = document.querySelector(`[data-connection-id="${connectionId}"]`);
                if (pathElement) {
                    pathElement.classList.add('flow-highlight');
                }
            });
            
            console.log(`‚ú® Flow highlighting updated - ${flowPaths.size} connections highlighted`);
        }
        
        // Connection deletion
        function handleConnectionClick(pathElement) {
            const connectionId = pathElement.dataset.connectionId;
            if (connectionId && connections.has(connectionId)) {
                deleteConnection(connectionId, pathElement);
            }
        }
        
        function deleteConnection(connectionId, pathElement) {
            const connection = connections.get(connectionId);
            
            // Add delete animation
            pathElement.classList.add('deleting');
            
            setTimeout(() => {
                // Remove from connections map
                connections.delete(connectionId);
                
                // Remove SVG path
                pathElement.remove();
                
                // Update port states
                connection.fromPort.classList.add('disconnected');
                connection.toPort.classList.add('disconnected');
                
                console.log('üóëÔ∏è Connection deleted:', connectionId);
                
                // üî• NEW: Update flow highlighting after deletion
                setTimeout(() => updateFlowHighlighting(), 100);
            }, 500);
        }
        
        // Drag and Drop Functions
        function startDragging(e, node) {
            isDragging = true;
            dragNode = node;
            
            const nodeRect = node.getBoundingClientRect();
            const canvasRect = document.getElementById('nodeCanvas').getBoundingClientRect();
            
            // Calculate mouse position relative to the canvas
            const mouseCanvasX = e.clientX - canvasRect.left;
            const mouseCanvasY = e.clientY - canvasRect.top;
            
            // Calculate node position relative to the canvas
            const nodeCanvasX = nodeRect.left - canvasRect.left;
            const nodeCanvasY = nodeRect.top - canvasRect.top;
            
            // Calculate offset from mouse to node's top-left corner
            dragOffset = {
                x: mouseCanvasX - nodeCanvasX,
                y: mouseCanvasY - nodeCanvasY
            };
            
            node.classList.add('dragging');
            
            // Activate canvas drag visual feedback
            const canvas = document.getElementById('nodeCanvas');
            canvas.classList.add('dragging-active');
            
            console.log('üñ±Ô∏è Started dragging:', node.dataset.nodeId, 
                       'Mouse:', {x: mouseCanvasX, y: mouseCanvasY}, 
                       'Node:', {x: nodeCanvasX, y: nodeCanvasY},
                       'Offset:', dragOffset);
        }
        
        function updateDragging(e) {
            if (!dragNode) return;
            
            const canvasRect = document.getElementById('nodeCanvas').getBoundingClientRect();
            
            // Calculate new position based on mouse and offset
            const mouseCanvasX = e.clientX - canvasRect.left;
            const mouseCanvasY = e.clientY - canvasRect.top;
            
            let x = mouseCanvasX - dragOffset.x;
            let y = mouseCanvasY - dragOffset.y;
            
            // Snap to grid
            x = snapToGrid(x);
            y = snapToGrid(y);
            
            // Constrain to canvas bounds
            const nodeWidth = 150;
            const nodeHeight = 80;
            x = Math.max(0, Math.min(x, canvasRect.width - nodeWidth));
            y = Math.max(0, Math.min(y, canvasRect.height - nodeHeight));
            
            // Update node position
            dragNode.style.left = x + 'px';
            dragNode.style.top = y + 'px';
            
            // Update stored position
            const nodeId = dragNode.dataset.nodeId;
            if (nodes.has(nodeId)) {
                nodes.get(nodeId).x = x;
                nodes.get(nodeId).y = y;
            }
            
            // Redraw connections in real-time
            redrawConnections();
        }
        
        function stopDragging() {
            if (dragNode) {
                dragNode.classList.remove('dragging');
                
                // Deactivate canvas drag visual feedback
                const canvas = document.getElementById('nodeCanvas');
                canvas.classList.remove('dragging-active');
                
                // Restore transition for smooth effects after drag
                dragNode.style.transition = 'all 0.2s ease';
                
                // Final snap to grid position
                const finalX = snapToGrid(parseInt(dragNode.style.left));
                const finalY = snapToGrid(parseInt(dragNode.style.top));
                
                dragNode.style.left = finalX + 'px';
                dragNode.style.top = finalY + 'px';
                
                // Update stored position with final snapped values
                const nodeId = dragNode.dataset.nodeId;
                if (nodes.has(nodeId)) {
                    nodes.get(nodeId).x = finalX;
                    nodes.get(nodeId).y = finalY;
                }
                
                // Final connection redraw
                redrawConnections();
                
                console.log('üñ±Ô∏è Stopped dragging:', dragNode.dataset.nodeId, 'Final pos:', {x: finalX, y: finalY});
            }
            
            isDragging = false;
            dragNode = null;
            dragOffset = { x: 0, y: 0 };
        }
        
        function snapToGrid(value) {
            return Math.round(value / GRID_SIZE) * GRID_SIZE;
        }
        
        // Add Layer functionality
        document.getElementById('addLayerBtn').addEventListener('click', function() {
            showLayerTypeModal();
        });
        
        function showLayerTypeModal() {
            // Create modal HTML
            const modalHTML = `
                <div class="modal fade" id="layerTypeModal" tabindex="-1">
                    <div class="modal-dialog modal-dialog-centered">
                        <div class="modal-content">
                            <div class="modal-header">
                                <h5 class="modal-title">
                                    <i class="fas fa-layer-group me-2"></i>
                                    Select Layer Type
                                </h5>
                                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                            </div>
                            <div class="modal-body">
                                <div class="row g-3">
                                    ${Object.entries(layerTypes).map(([key, type]) => `
                                        <div class="col-6">
                                            <div class="layer-type-card" data-layer-type="${key}">
                                                <div class="layer-type-icon" style="background: ${type.color}"></div>
                                                <div class="layer-type-name">${type.name}</div>
                                            </div>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <style>
                    .layer-type-card {
                        border: 2px solid #e5e7eb;
                        border-radius: 8px;
                        padding: 1rem;
                        text-align: center;
                        cursor: pointer;
                        transition: all 0.2s ease;
                    }
                    .layer-type-card:hover {
                        border-color: #3b82f6;
                        transform: translateY(-2px);
                    }
                    .layer-type-icon {
                        width: 40px;
                        height: 40px;
                        border-radius: 50%;
                        margin: 0 auto 0.5rem;
                    }
                    .layer-type-name {
                        font-weight: 600;
                        color: #374151;
                    }
                </style>
            `;
            
            // Remove existing modal
            const existingModal = document.getElementById('layerTypeModal');
            if (existingModal) existingModal.remove();
            
            // Add modal to DOM
            document.body.insertAdjacentHTML('beforeend', modalHTML);
            
            // Show modal
            const modal = new bootstrap.Modal(document.getElementById('layerTypeModal'));
            modal.show();
            
            // Handle layer type selection
            document.querySelectorAll('.layer-type-card').forEach(card => {
                card.addEventListener('click', function() {
                    const layerType = this.dataset.layerType;
                    addLayer(layerType);
                    modal.hide();
                });
            });
            
            console.log('üé≠ Layer type modal opened');
        }
        
        function addLayer(layerType) {
            const typeConfig = layerTypes[layerType];
            const nodeId = `layer-${++nodeCounter}`;
            const canvas = document.getElementById('nodeCanvas');
            
            // Smart positioning based on existing nodes
            const position = calculateSmartPosition(canvas);
            
            // Create node HTML with intelligent bidirectional ports
            const nodeHTML = `
                <div class="layer-node layer-${layerType}" data-node-id="${nodeId}" 
                     style="left: ${position.x}px; top: ${position.y}px; position: absolute;">
                    
                    <!-- Left smart port -->
                    <div class="connection-port smart-port left-side disconnected" 
                         data-port-type="smart" data-side="left" data-preferred="input"></div>
                    
                    <!-- Node content -->
                    <div class="node-content">
                        <div class="node-title">${typeConfig.name}</div>
                        <div class="node-features">${typeConfig.defaultFeatures} features</div>
                    </div>
                    
                    <!-- Right smart port -->
                    <div class="connection-port smart-port right-side disconnected" 
                         data-port-type="smart" data-side="right" data-preferred="output"></div>
                    
                </div>
            `;
            
            canvas.insertAdjacentHTML('beforeend', nodeHTML);
            
            // Store node data
            nodes.set(nodeId, {
                type: layerType,
                features: typeConfig.defaultFeatures,
                x: position.x, 
                y: position.y
            });
            
            console.log(`‚ûï Added ${typeConfig.name} layer at (${position.x}, ${position.y}) with ID: ${nodeId}`);
            
            // Auto-select the new node
            const newNode = document.querySelector(`[data-node-id="${nodeId}"]`);
            document.querySelectorAll('.layer-node').forEach(n => n.classList.remove('selected'));
            newNode.classList.add('selected');
            updateParametersPanel(newNode);
            
            // üî• NEW: Check layout optimization
            setTimeout(() => optimizeNodeLayout(), 200);
        }
        
        function calculateSmartPosition(canvas) {
            const canvasRect = canvas.getBoundingClientRect();
            const existingNodes = canvas.querySelectorAll('.layer-node[data-node-id]:not([data-node-id="input"]):not([data-node-id="output"])');
            
            // Default position (center)
            let x = snapToGrid((canvasRect.width / 2) - 75);
            let y = snapToGrid((canvasRect.height / 2) - 40);
            
            if (existingNodes.length === 0) {
                // First layer - position between input and output
                x = snapToGrid(canvasRect.width * 0.4);
                y = snapToGrid((canvasRect.height / 2) - 40);
            } else {
                // Find a free spot
                const occupiedPositions = new Set();
                existingNodes.forEach(node => {
                    const nodeX = parseInt(node.style.left);
                    const nodeY = parseInt(node.style.top);
                    occupiedPositions.add(`${nodeX},${nodeY}`);
                });
                
                // Try positions in a spiral pattern from center
                const centerX = snapToGrid((canvasRect.width / 2) - 75);
                const centerY = snapToGrid((canvasRect.height / 2) - 40);
                
                for (let radius = 0; radius < 200; radius += GRID_SIZE) {
                    for (let angle = 0; angle < 360; angle += 45) {
                        const testX = snapToGrid(centerX + radius * Math.cos(angle * Math.PI / 180));
                        const testY = snapToGrid(centerY + radius * Math.sin(angle * Math.PI / 180));
                        
                        // Check bounds
                        if (testX >= 0 && testX <= canvasRect.width - 150 && 
                            testY >= 0 && testY <= canvasRect.height - 80) {
                            
                            if (!occupiedPositions.has(`${testX},${testY}`)) {
                                return { x: testX, y: testY };
                            }
                        }
                    }
                }
            }
            
            return { x, y };
        }
        
        // üî• NEW: Enhanced stacking and flexible layout helper
        function optimizeNodeLayout() {
            const canvas = document.getElementById('nodeCanvas');
            const allNodes = canvas.querySelectorAll('.layer-node[data-node-id]');
            const canvasRect = canvas.getBoundingClientRect();
            
            // Group nodes by vertical regions for better stacking
            const regions = {
                top: [],
                middle: [],
                bottom: []
            };
            
            allNodes.forEach(node => {
                const rect = node.getBoundingClientRect();
                const relativeY = rect.top - canvasRect.top;
                const heightPercent = relativeY / canvasRect.height;
                
                if (heightPercent < 0.33) regions.top.push(node);
                else if (heightPercent < 0.66) regions.middle.push(node);
                else regions.bottom.push(node);
            });
            
            console.log('üìä Layout analysis:', {
                top: regions.top.length,
                middle: regions.middle.length,
                bottom: regions.bottom.length
            });
            
            // Detect overlapping nodes and suggest repositioning
            let overlaps = 0;
            allNodes.forEach((node1, i) => {
                allNodes.forEach((node2, j) => {
                    if (i !== j && nodesOverlap(node1, node2)) {
                        overlaps++;
                        console.log('‚ö†Ô∏è Overlap detected between:', 
                                   node1.dataset.nodeId, 'and', node2.dataset.nodeId);
                    }
                });
            });
            
            if (overlaps > 0) {
                console.log('üí° Tip: Drag nodes to avoid overlaps or use Auto Layout');
            }
        }
        
        function nodesOverlap(node1, node2) {
            const rect1 = node1.getBoundingClientRect();
            const rect2 = node2.getBoundingClientRect();
            
            return !(rect1.right < rect2.left || 
                    rect1.left > rect2.right || 
                    rect1.bottom < rect2.top || 
                    rect1.top > rect2.bottom);
        }
        
        // Update parameters panel based on selected node
        function updateParametersPanel(node) {
            const nodeType = node.querySelector('.node-title').textContent;
            const nodeId = node.dataset.nodeId;
            
            console.log(`üìä Updating parameters for ${nodeType} (${nodeId})`);
            
            // Update panel title
            const panelTitle = document.querySelector('.designer-panel:last-child .panel-title');
            panelTitle.textContent = `${nodeType} Parameters`;
            
            // This would update form fields based on layer type
            // For now, just log the selection
        }
        
        // Auto layout functionality
        document.querySelector('.btn-outline-primary').addEventListener('click', function() {
            console.log('‚ú® Auto layout triggered - arranging nodes...');
            autoArrangeNodes();
        });
        
        function autoArrangeNodes() {
            const canvas = document.getElementById('nodeCanvas');
            const allNodes = canvas.querySelectorAll('.layer-node[data-node-id]:not([data-node-id="input"]):not([data-node-id="output"])');
            const canvasRect = canvas.getBoundingClientRect();
            
            if (allNodes.length === 0) return;
            
            // Calculate positions for horizontal arrangement
            const startX = 200;
            const endX = canvasRect.width - 250;
            const spacing = allNodes.length > 1 ? (endX - startX) / (allNodes.length - 1) : 0;
            const centerY = canvasRect.height / 2 - 40;
            
            allNodes.forEach((node, index) => {
                const x = startX + (index * spacing);
                node.style.left = x + 'px';
                node.style.top = centerY + 'px';
                
                // Update stored position
                const nodeId = node.dataset.nodeId;
                if (nodes.has(nodeId)) {
                    nodes.get(nodeId).x = x;
                    nodes.get(nodeId).y = centerY;
                }
            });
            
            // Redraw all connections
            redrawConnections();
        }
        
        function redrawConnections() {
            const svg = document.getElementById('connectionsSvg');
            svg.innerHTML = ''; // Clear existing paths
            
            connections.forEach((connection, id) => {
                drawConnection(connection.fromPort, connection.toPort, id);
            });
        }
        
        // Node deletion functionality
        function deleteSelectedNode() {
            const selectedNode = document.querySelector('.layer-node.selected');
            const nodeId = selectedNode?.dataset.nodeId;
            if (!selectedNode || nodeId === 'input' || nodeId === 'output') {
                console.log('‚ö†Ô∏è Cannot delete Input/Output nodes - they are movable but not deletable');
                return;
            }
            
            
            // Find and delete all connections to/from this node
            const connectionsToDelete = [];
            connections.forEach((connection, id) => {
                if (connection.from === nodeId || connection.to === nodeId) {
                    connectionsToDelete.push(id);
                }
            });
            
            // Delete connections
            connectionsToDelete.forEach(id => {
                const pathElement = document.querySelector(`[data-connection-id="${id}"]`);
                if (pathElement) {
                    deleteConnection(id, pathElement);
                } else {
                    connections.delete(id);
                }
            });
            
            // Remove from nodes map
            nodes.delete(nodeId);
            
            // Remove node element with animation
            selectedNode.style.transition = 'all 0.3s ease';
            selectedNode.style.opacity = '0';
            selectedNode.style.transform = 'scale(0.8)';
            
            setTimeout(() => {
                selectedNode.remove();
                
                // Select input node by default
                const inputNode = document.querySelector('.node-input');
                inputNode.classList.add('selected');
                updateParametersPanel(inputNode);
                
                console.log('üóëÔ∏è Node deleted:', nodeId);
            }, 300);
        }
        
        // Action buttons logging
        document.querySelectorAll('.btn-action').forEach(btn => {
            btn.addEventListener('click', function() {
                const action = this.textContent.trim();
                console.log(`üîß Action triggered: ${action}`);
            });
        });
        
        // Delete node button functionality
        document.addEventListener('click', function(e) {
            if (e.target.closest('#deleteNodeBtn')) {
                deleteSelectedNode();
            }
        });
        
        // Curve editing UI buttons
        document.getElementById('saveCurveBtn').addEventListener('click', saveCurveEdit);
        document.getElementById('cancelCurveBtn').addEventListener('click', cancelCurveEdit);
        
        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Delete' || e.key === 'Backspace') {
                e.preventDefault();
                
                // üî• FIX: Check if we're editing a curve first
                if (isEditingCurve && editingPath) {
                    console.log('üóëÔ∏è Deleting connection while editing curve');
                    const connectionId = editingPath.dataset.connectionId;
                    if (connectionId && connections.has(connectionId)) {
                        // Cancel curve editing first
                        cancelCurveEdit();
                        // Then delete the connection
                        deleteConnection(connectionId, editingPath);
                    }
                    return;
                }
                
                // üî• FIX: Check for selected connection path
                const selectedPath = document.querySelector('.connection-path.connection-selected');
                if (selectedPath) {
                    console.log('üóëÔ∏è Deleting selected connection');
                    const connectionId = selectedPath.dataset.connectionId;
                    if (connectionId && connections.has(connectionId)) {
                        deleteConnection(connectionId, selectedPath);
                    }
                    return;
                }
                
                // Finally, check for selected nodes (excluding Input/Output)
                const selectedNode = document.querySelector('.layer-node.selected');
                const nodeId = selectedNode?.dataset.nodeId;
                if (selectedNode && nodeId !== 'input' && nodeId !== 'output') {
                    deleteSelectedNode();
                }
            } else if (e.key === 'Escape') {
                if (isEditingCurve) {
                    cancelCurveEdit();
                } else if (isConnecting) {
                    cancelConnectionPreview();
                }
            }
        });
        
        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            initializeCanvas();
            console.log('üöÄ Model Designer initialized successfully');
            console.log('');
            console.log('üéØ NEW FEATURES:');
            console.log('   üîÑ Input/Output nodes are now MOVABLE - drag them anywhere!');
            console.log('   üß† SMART PORTS - each node has 2 intelligent ports (left/right)');
            console.log('   üîÄ Automatic role adaptation - ports become input/output as needed');
            console.log('   ‚ú® Flow highlighting - paths from Input are highlighted in blue');
            console.log('   üìê Double-click connections to edit curves (FIXED!)');
            console.log('');
            console.log('üìù SMART PORT SYSTEM:');
            console.log('   ‚Ä¢ Each layer has 2 smart ports: LEFT (prefers input) + RIGHT (prefers output)');
            console.log('   ‚Ä¢ Ports adapt automatically: grey ‚Üí green (input) or red (output)');
            console.log('   ‚Ä¢ Click any port to start connection, drop on any port to complete');
            console.log('   ‚Ä¢ Perfect for vertical stacking and complex routing');
            console.log('');
            console.log('üìù USAGE:');
            console.log('   ‚Ä¢ Hold down any port ‚Üí preview connection line');
            console.log('   ‚Ä¢ Ctrl+Click connections to delete them');
            console.log('   ‚Ä¢ Double-click connections to edit curve shape'); 
            console.log('   ‚Ä¢ Drag ANY node to reposition (including Input/Output)');
            console.log('‚å®Ô∏è Press Delete/Backspace to remove selected layer, Escape to cancel actions');
        });
    </script>
</body>
</html>