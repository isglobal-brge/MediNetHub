<!DOCTYPE html>
<html lang="ca">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MediNet - Blueprint Model Designer (UE5 Style)</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        :root {
            /* MediNet Blueprint Color Palette - White & Blue Theme */
            --bp-bg-dark: #f8f9fa;
            --bp-bg-medium: #ffffff;
            --bp-bg-light: #e9ecef;
            --bp-grid-color: rgba(13, 110, 253, 0.08);
            --bp-grid-accent: rgba(13, 110, 253, 0.15);
            --bp-text-primary: #212529;
            --bp-text-secondary: #6c757d;
            --bp-accent-blue: #0d6efd;
            --bp-accent-blue-light: #cfe2ff;
            --bp-accent-blue-dark: #0a58ca;
            --bp-accent-green: #198754;
            --bp-accent-red: #dc3545;
            --bp-accent-yellow: #ffc107;
            --bp-accent-purple: #6f42c1;
            --bp-node-bg: #ffffff;
            --bp-node-header: #0d6efd;
            --bp-node-border: rgba(13, 110, 253, 0.3);
            --bp-connection-data: #0d6efd;
            --bp-pin-input: #198754;
            --bp-pin-output: #dc3545;
            --bp-selection: rgba(13, 110, 253, 0.2);
            --bp-shadow: rgba(0, 0, 0, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bp-bg-medium);
            color: var(--bp-text-primary);
            overflow: hidden;
            height: 100vh;
        }

        /* Main Layout */
        .blueprint-container {
            display: flex;
            height: 100vh;
            width: 100vw;
        }

        /* Sidebar - Layer Palette */
        .layer-palette {
            width: 280px;
            background: var(--bp-bg-medium);
            border-right: 2px solid var(--bp-bg-light);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: 2px 0 8px var(--bp-shadow);
        }

        .palette-header {
            padding: 15px;
            background: var(--bp-accent-blue-light);
            border-bottom: 2px solid var(--bp-accent-blue);
        }

        .palette-header h5 {
            margin: 0;
            font-size: 14px;
            font-weight: 600;
            color: var(--bp-accent-blue);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .palette-search {
            margin-top: 10px;
        }

        .palette-search input {
            width: 100%;
            background: var(--bp-bg-medium);
            border: 1px solid var(--bp-accent-blue);
            color: var(--bp-text-primary);
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 12px;
        }

        .palette-search input:focus {
            outline: none;
            border-color: var(--bp-accent-blue-dark);
            box-shadow: 0 0 0 3px var(--bp-accent-blue-light);
        }

        .palette-content {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }

        .palette-category {
            margin-bottom: 15px;
        }

        .palette-category-title {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            color: var(--bp-text-secondary);
            margin-bottom: 8px;
            padding: 5px 8px;
            background: var(--bp-bg-dark);
            border-radius: 3px;
        }

        .palette-item {
            background: var(--bp-bg-medium);
            border: 1px solid var(--bp-bg-light);
            border-radius: 6px;
            padding: 10px 12px;
            margin-bottom: 6px;
            cursor: grab;
            transition: all 0.2s;
            font-size: 12px;
            box-shadow: 0 1px 3px var(--bp-shadow);
        }

        .palette-item:hover {
            border-color: var(--bp-accent-blue);
            background: var(--bp-accent-blue-light);
            transform: translateX(5px);
            box-shadow: 0 2px 6px var(--bp-shadow);
        }

        .palette-item:active {
            cursor: grabbing;
        }

        .palette-item-icon {
            display: inline-block;
            width: 20px;
            margin-right: 8px;
            text-align: center;
        }

        /* Canvas Area */
        .canvas-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
        }

        /* Toolbar */
        .canvas-toolbar {
            background: var(--bp-bg-medium);
            border-bottom: 2px solid var(--bp-bg-light);
            padding: 10px 15px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            box-shadow: 0 2px 4px var(--bp-shadow);
        }

        .toolbar-section {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .toolbar-btn {
            background: var(--bp-bg-medium);
            border: 1px solid var(--bp-accent-blue);
            color: var(--bp-accent-blue);
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
            font-weight: 500;
        }

        .toolbar-btn:hover {
            background: var(--bp-accent-blue);
            color: white;
            box-shadow: 0 2px 6px var(--bp-shadow);
        }

        .toolbar-btn.active {
            background: var(--bp-accent-blue);
            border-color: var(--bp-accent-blue-dark);
            color: white;
        }

        .toolbar-separator {
            width: 1px;
            height: 24px;
            background: var(--bp-bg-light);
            margin: 0 5px;
        }

        /* Blueprint Canvas */
        .blueprint-canvas {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: #fafbfc;
            /* Grid pattern */
            background-image:
                linear-gradient(var(--bp-grid-color) 1px, transparent 1px),
                linear-gradient(90deg, var(--bp-grid-color) 1px, transparent 1px),
                linear-gradient(var(--bp-grid-accent) 1.5px, transparent 1.5px),
                linear-gradient(90deg, var(--bp-grid-accent) 1.5px, transparent 1.5px);
            background-size: 20px 20px, 20px 20px, 100px 100px, 100px 100px;
            background-position: -1px -1px, -1px -1px, -1px -1px, -1px -1px;
        }

        .canvas-viewport {
            position: absolute;
            width: 100%;
            height: 100%;
            transform-origin: 0 0;
            cursor: grab;
        }

        .canvas-viewport.panning {
            cursor: grabbing;
        }

        /* SVG Layer for connections */
        .connections-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        /* Nodes Layer */
        .nodes-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
        }

        /* Blueprint Node */
        .bp-node {
            position: absolute;
            min-width: 200px;
            background: var(--bp-node-bg);
            border: 2px solid var(--bp-node-border);
            border-radius: 8px;
            box-shadow: 0 4px 12px var(--bp-shadow);
            cursor: move;
            transition: box-shadow 0.2s, border-color 0.2s;
            will-change: transform;
        }

        .bp-node:hover {
            box-shadow: 0 6px 20px rgba(13, 110, 253, 0.3);
        }

        .bp-node.selected {
            border-color: var(--bp-accent-blue-dark);
            box-shadow: 0 0 0 4px var(--bp-selection);
        }

        .bp-node.dragging {
            opacity: 0.8;
            cursor: grabbing;
        }

        /* Node Header */
        .bp-node-header {
            background: linear-gradient(135deg, var(--bp-accent-blue), var(--bp-accent-blue-dark));
            padding: 10px 12px;
            border-radius: 6px 6px 0 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 2px solid var(--bp-accent-blue-dark);
            color: white;
        }

        .bp-node-title {
            font-size: 13px;
            font-weight: 600;
            color: white;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .bp-node-icon {
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .bp-node-actions {
            display: flex;
            gap: 4px;
        }

        .node-action-btn {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            cursor: pointer;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .node-action-btn:hover {
            background: rgba(255, 255, 255, 0.35);
            transform: scale(1.1);
        }

        /* Node Body */
        .bp-node-body {
            padding: 12px;
        }

        /* Node Pins */
        .bp-node-pins {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .bp-pin-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            min-height: 24px;
        }

        .bp-pin {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 11px;
            color: var(--bp-text-secondary);
        }

        .bp-pin-connector {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 2px solid;
            background: var(--bp-node-bg);
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            z-index: 10;
        }

        .bp-pin-connector:hover {
            transform: scale(1.3);
            box-shadow: 0 0 10px currentColor;
        }

        .bp-pin-connector.connecting {
            animation: pulse 0.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }

        .bp-pin.input .bp-pin-connector {
            border-color: var(--bp-pin-input);
            margin-right: 6px;
        }

        .bp-pin.output .bp-pin-connector {
            border-color: var(--bp-pin-output);
            margin-left: 6px;
        }

        .bp-pin.input .bp-pin-connector.connected,
        .bp-pin.output .bp-pin-connector.connected {
            background: currentColor;
        }

        .bp-pin-label {
            user-select: none;
        }

        .bp-pin.input {
            flex-direction: row;
        }

        .bp-pin.output {
            flex-direction: row-reverse;
        }

        /* Node Types Styling */
        .bp-node.type-input .bp-node-header {
            background: linear-gradient(135deg, #0066cc, #004499);
        }
        .bp-node.type-linear .bp-node-header {
            background: linear-gradient(135deg, #28a745, #1e7e34);
        }
        .bp-node.type-conv .bp-node-header {
            background: linear-gradient(135deg, #6f42c1, #5a3399);
        }
        .bp-node.type-activation .bp-node-header {
            background: linear-gradient(135deg, #ffc107, #e0a800);
        }
        .bp-node.type-pool .bp-node-header {
            background: linear-gradient(135deg, #17a2b8, #138496);
        }
        .bp-node.type-norm .bp-node-header {
            background: linear-gradient(135deg, #fd7e14, #e8590c);
        }
        .bp-node.type-dropout .bp-node-header {
            background: linear-gradient(135deg, #6c757d, #545b62);
        }
        .bp-node.type-output .bp-node-header {
            background: linear-gradient(135deg, #dc3545, #bd2130);
        }
        .bp-node.type-operation .bp-node-header {
            background: linear-gradient(135deg, #aa44ff, #8833cc);
        }

        /* Connection Lines (SVG) */
        .bp-connection {
            stroke-width: 2.5;
            fill: none;
            stroke: var(--bp-connection-data);
            filter: drop-shadow(0 0 3px currentColor);
            cursor: pointer;
            transition: all 0.2s;
        }

        .bp-connection:hover {
            stroke-width: 3.5;
            filter: drop-shadow(0 0 6px currentColor);
        }

        .bp-connection.selected {
            stroke: var(--bp-accent-blue);
            stroke-width: 3.5;
        }

        .bp-connection.temporary {
            stroke: var(--bp-accent-yellow);
            stroke-dasharray: 5, 5;
            animation: dash-flow 0.5s linear infinite;
        }

        @keyframes dash-flow {
            to { stroke-dashoffset: -10; }
        }

        /* Properties Panel */
        .properties-panel {
            width: 320px;
            background: var(--bp-bg-medium);
            border-left: 2px solid var(--bp-bg-light);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: -2px 0 8px var(--bp-shadow);
        }

        .properties-header {
            padding: 15px;
            background: var(--bp-accent-blue-light);
            border-bottom: 2px solid var(--bp-accent-blue);
        }

        .properties-header h5 {
            margin: 0;
            font-size: 14px;
            font-weight: 600;
            color: var(--bp-accent-blue);
        }

        .properties-content {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }

        .property-group {
            margin-bottom: 20px;
        }

        .property-group-title {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            color: var(--bp-text-secondary);
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid var(--bp-bg-light);
        }

        .property-field {
            margin-bottom: 12px;
        }

        .property-label {
            font-size: 11px;
            color: var(--bp-text-secondary);
            margin-bottom: 4px;
            display: block;
        }

        .property-input {
            width: 100%;
            background: var(--bp-bg-medium);
            border: 1px solid var(--bp-accent-blue);
            color: var(--bp-text-primary);
            padding: 6px 8px;
            border-radius: 4px;
            font-size: 12px;
        }

        .property-input:focus {
            outline: none;
            border-color: var(--bp-accent-blue-dark);
            box-shadow: 0 0 0 3px var(--bp-accent-blue-light);
        }

        .property-input:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Canvas Info Overlay */
        .canvas-info {
            position: absolute;
            bottom: 15px;
            left: 15px;
            background: rgba(255, 255, 255, 0.95);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 11px;
            color: var(--bp-text-secondary);
            z-index: 100;
            display: flex;
            gap: 15px;
            border: 1px solid var(--bp-bg-light);
            box-shadow: 0 2px 8px var(--bp-shadow);
        }

        .canvas-info-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        /* Minimap */
        .canvas-minimap {
            position: absolute;
            bottom: 15px;
            right: 15px;
            width: 200px;
            height: 150px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid var(--bp-bg-light);
            border-radius: 4px;
            z-index: 100;
        }

        /* Context Menu */
        .context-menu {
            position: absolute;
            background: var(--bp-bg-medium);
            border: 1px solid var(--bp-bg-light);
            border-radius: 4px;
            padding: 5px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            display: none;
            min-width: 200px;
        }

        .context-menu.show {
            display: block;
        }

        .context-menu-item {
            padding: 8px 12px;
            font-size: 12px;
            color: var(--bp-text-primary);
            cursor: pointer;
            border-radius: 3px;
            transition: all 0.2s;
        }

        .context-menu-item:hover {
            background: var(--bp-bg-light);
        }

        .context-menu-separator {
            height: 1px;
            background: var(--bp-bg-light);
            margin: 5px 0;
        }

        /* Selection Box */
        .selection-box {
            position: absolute;
            border: 2px solid var(--bp-accent-blue);
            background: var(--bp-selection);
            pointer-events: none;
            z-index: 999;
            display: none;
        }

        .selection-box.active {
            display: block;
        }

        /* Empty State */
        .empty-state {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: var(--bp-text-secondary);
            pointer-events: none;
        }

        .empty-state-icon {
            font-size: 64px;
            margin-bottom: 15px;
            opacity: 0.3;
        }

        .empty-state-text {
            font-size: 14px;
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bp-bg-dark);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--bp-bg-light);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #4a4a4a;
        }

        /* Zoom Controls */
        .zoom-controls {
            position: absolute;
            top: 15px;
            right: 15px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 100;
        }

        .zoom-btn {
            width: 36px;
            height: 36px;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid var(--bp-accent-blue);
            border-radius: 6px;
            color: var(--bp-accent-blue);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            transition: all 0.2s;
            box-shadow: 0 2px 6px var(--bp-shadow);
        }

        .zoom-btn:hover {
            background: var(--bp-accent-blue);
            color: white;
        }

        .zoom-level {
            width: 36px;
            height: 36px;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid var(--bp-bg-light);
            border-radius: 6px;
            color: var(--bp-text-secondary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: 600;
            box-shadow: 0 2px 6px var(--bp-shadow);
        }

        /* Tooltips */
        .bp-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: var(--bp-text-primary);
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 11px;
            pointer-events: none;
            z-index: 2000;
            display: none;
            white-space: nowrap;
        }

        .bp-tooltip.show {
            display: block;
        }

        /* Loading Overlay */
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 3000;
        }

        .loading-overlay.show {
            display: flex;
        }

        .loading-spinner {
            border: 3px solid var(--bp-bg-light);
            border-top: 3px solid var(--bp-accent-blue);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <!-- Main Container -->
    <div class="blueprint-container">

        <!-- Left Sidebar - Layer Palette -->
        <div class="layer-palette">
            <div class="palette-header">
                <h5>
                    <i class="fas fa-layer-group"></i>
                    Capes de Xarxa
                </h5>
                <div class="palette-search">
                    <input type="text" id="paletteSearch" placeholder="Buscar capa...">
                </div>
            </div>
            <div class="palette-content">
                <!-- Input Layers -->
                <div class="palette-category">
                    <div class="palette-category-title">Entrada</div>
                    <div class="palette-item" draggable="true" data-layer-type="input">
                        <span class="palette-item-icon"><i class="fas fa-arrow-right"></i></span>
                        Input Layer
                    </div>
                </div>

                <!-- Dense Layers -->
                <div class="palette-category">
                    <div class="palette-category-title">Capes Denses</div>
                    <div class="palette-item" draggable="true" data-layer-type="linear">
                        <span class="palette-item-icon"><i class="fas fa-equals"></i></span>
                        Linear (Dense)
                    </div>
                    <div class="palette-item" draggable="true" data-layer-type="dropout">
                        <span class="palette-item-icon"><i class="fas fa-random"></i></span>
                        Dropout
                    </div>
                </div>

                <!-- Convolutional Layers -->
                <div class="palette-category">
                    <div class="palette-category-title">Convolucionals</div>
                    <div class="palette-item" draggable="true" data-layer-type="conv2d">
                        <span class="palette-item-icon"><i class="fas fa-th"></i></span>
                        Conv2D
                    </div>
                    <div class="palette-item" draggable="true" data-layer-type="conv3d">
                        <span class="palette-item-icon"><i class="fas fa-cube"></i></span>
                        Conv3D
                    </div>
                    <div class="palette-item" draggable="true" data-layer-type="maxpool2d">
                        <span class="palette-item-icon"><i class="fas fa-compress"></i></span>
                        MaxPool2D
                    </div>
                    <div class="palette-item" draggable="true" data-layer-type="avgpool2d">
                        <span class="palette-item-icon"><i class="fas fa-compress-alt"></i></span>
                        AvgPool2D
                    </div>
                </div>

                <!-- Activation Layers -->
                <div class="palette-category">
                    <div class="palette-category-title">Activacions</div>
                    <div class="palette-item" draggable="true" data-layer-type="relu">
                        <span class="palette-item-icon"><i class="fas fa-chart-line"></i></span>
                        ReLU
                    </div>
                    <div class="palette-item" draggable="true" data-layer-type="sigmoid">
                        <span class="palette-item-icon"><i class="fas fa-wave-square"></i></span>
                        Sigmoid
                    </div>
                    <div class="palette-item" draggable="true" data-layer-type="tanh">
                        <span class="palette-item-icon"><i class="fas fa-water"></i></span>
                        Tanh
                    </div>
                    <div class="palette-item" draggable="true" data-layer-type="softmax">
                        <span class="palette-item-icon"><i class="fas fa-chart-pie"></i></span>
                        Softmax
                    </div>
                </div>

                <!-- Normalization Layers -->
                <div class="palette-category">
                    <div class="palette-category-title">Normalitzaci√≥</div>
                    <div class="palette-item" draggable="true" data-layer-type="batchnorm">
                        <span class="palette-item-icon"><i class="fas fa-balance-scale"></i></span>
                        BatchNorm
                    </div>
                    <div class="palette-item" draggable="true" data-layer-type="layernorm">
                        <span class="palette-item-icon"><i class="fas fa-layer-group"></i></span>
                        LayerNorm
                    </div>
                </div>

                <!-- Utility Layers -->
                <div class="palette-category">
                    <div class="palette-category-title">Utilitats</div>
                    <div class="palette-item" draggable="true" data-layer-type="flatten">
                        <span class="palette-item-icon"><i class="fas fa-stream"></i></span>
                        Flatten
                    </div>
                    <div class="palette-item" draggable="true" data-layer-type="reshape">
                        <span class="palette-item-icon"><i class="fas fa-shapes"></i></span>
                        Reshape
                    </div>
                </div>

                <!-- Operations -->
                <div class="palette-category">
                    <div class="palette-category-title">Operacions</div>
                    <div class="palette-item" draggable="true" data-layer-type="add">
                        <span class="palette-item-icon"><i class="fas fa-plus"></i></span>
                        Add
                    </div>
                    <div class="palette-item" draggable="true" data-layer-type="concatenate">
                        <span class="palette-item-icon"><i class="fas fa-code-branch"></i></span>
                        Concatenate
                    </div>
                </div>

                <!-- Output Layers -->
                <div class="palette-category">
                    <div class="palette-category-title">Sortida</div>
                    <div class="palette-item" draggable="true" data-layer-type="output">
                        <span class="palette-item-icon"><i class="fas fa-flag-checkered"></i></span>
                        Output Layer
                    </div>
                </div>
            </div>
        </div>

        <!-- Center - Canvas Area -->
        <div class="canvas-area">
            <!-- Toolbar -->
            <div class="canvas-toolbar">
                <div class="toolbar-section">
                    <button class="toolbar-btn" id="btnNew" title="Nou Blueprint">
                        <i class="fas fa-file"></i>
                        <span>Nou</span>
                    </button>
                    <button class="toolbar-btn" id="btnOpen" title="Obrir Blueprint">
                        <i class="fas fa-folder-open"></i>
                        <span>Obrir</span>
                    </button>
                    <button class="toolbar-btn" id="btnSave" title="Desar Blueprint">
                        <i class="fas fa-save"></i>
                        <span>Desar</span>
                    </button>
                </div>

                <div class="toolbar-separator"></div>

                <div class="toolbar-section">
                    <button class="toolbar-btn" id="btnUndo" title="Desfer">
                        <i class="fas fa-undo"></i>
                    </button>
                    <button class="toolbar-btn" id="btnRedo" title="Refer">
                        <i class="fas fa-redo"></i>
                    </button>
                </div>

                <div class="toolbar-separator"></div>

                <div class="toolbar-section">
                    <button class="toolbar-btn" id="btnAutoLayout" title="Disposici√≥ Autom√†tica">
                        <i class="fas fa-magic"></i>
                        <span>Auto Layout</span>
                    </button>
                    <button class="toolbar-btn" id="btnAlignLeft" title="Alinear Esquerra">
                        <i class="fas fa-align-left"></i>
                    </button>
                    <button class="toolbar-btn" id="btnAlignCenter" title="Alinear Centre">
                        <i class="fas fa-align-center"></i>
                    </button>
                </div>

                <div class="toolbar-separator"></div>

                <div class="toolbar-section">
                    <button class="toolbar-btn" id="btnCompile" title="Compilar Model">
                        <i class="fas fa-cogs"></i>
                        <span>Compilar</span>
                    </button>
                    <button class="toolbar-btn" id="btnValidate" title="Validar Blueprint">
                        <i class="fas fa-check-circle"></i>
                        <span>Validar</span>
                    </button>
                </div>

                <div class="toolbar-section" style="margin-left: auto;">
                    <button class="toolbar-btn" id="btnHelp" title="Ajuda">
                        <i class="fas fa-question-circle"></i>
                    </button>
                </div>
            </div>

            <!-- Blueprint Canvas -->
            <div class="blueprint-canvas" id="blueprintCanvas">
                <!-- Zoom Controls -->
                <div class="zoom-controls">
                    <button class="zoom-btn" id="btnZoomIn" title="Apropar">
                        <i class="fas fa-plus"></i>
                    </button>
                    <div class="zoom-level" id="zoomLevel">100%</div>
                    <button class="zoom-btn" id="btnZoomOut" title="Allunyar">
                        <i class="fas fa-minus"></i>
                    </button>
                    <button class="zoom-btn" id="btnZoomFit" title="Ajustar a la Vista">
                        <i class="fas fa-expand"></i>
                    </button>
                </div>

                <!-- Canvas Viewport (Transform container) -->
                <div class="canvas-viewport" id="canvasViewport">
                    <!-- SVG Layer for Connections -->
                    <svg class="connections-layer" id="connectionsLayer">
                        <defs>
                            <filter id="glow">
                                <feGaussianBlur stdDeviation="2" result="coloredBlur"/>
                                <feMerge>
                                    <feMergeNode in="coloredBlur"/>
                                    <feMergeNode in="SourceGraphic"/>
                                </feMerge>
                            </filter>
                        </defs>
                    </svg>

                    <!-- Nodes Layer -->
                    <div class="nodes-layer" id="nodesLayer">
                        <!-- Nodes will be added here dynamically -->
                    </div>
                </div>

                <!-- Empty State -->
                <div class="empty-state" id="emptyState">
                    <div class="empty-state-icon">
                        <i class="fas fa-project-diagram"></i>
                    </div>
                    <div class="empty-state-text">
                        Arrossega capes des de l'esquerra per comen√ßar<br>
                        o fes clic dret per obrir el men√∫ contextual
                    </div>
                </div>

                <!-- Selection Box -->
                <div class="selection-box" id="selectionBox"></div>

                <!-- Canvas Info -->
                <div class="canvas-info">
                    <div class="canvas-info-item">
                        <i class="fas fa-cube"></i>
                        <span id="nodeCount">0 nodes</span>
                    </div>
                    <div class="canvas-info-item">
                        <i class="fas fa-link"></i>
                        <span id="connectionCount">0 connexions</span>
                    </div>
                    <div class="canvas-info-item">
                        <i class="fas fa-mouse-pointer"></i>
                        <span id="cursorPos">X: 0, Y: 0</span>
                    </div>
                </div>

                <!-- Minimap -->
                <div class="canvas-minimap" id="minimap">
                    <!-- Minimap content will be rendered here -->
                </div>
            </div>

            <!-- Context Menu -->
            <div class="context-menu" id="contextMenu">
                <div class="context-menu-item" data-action="add-node">
                    <i class="fas fa-plus"></i> Afegir Node
                </div>
                <div class="context-menu-item" data-action="paste">
                    <i class="fas fa-paste"></i> Enganxar
                </div>
                <div class="context-menu-separator"></div>
                <div class="context-menu-item" data-action="select-all">
                    <i class="fas fa-object-group"></i> Seleccionar Tot
                </div>
                <div class="context-menu-separator"></div>
                <div class="context-menu-item" data-action="reset-view">
                    <i class="fas fa-eye"></i> Reiniciar Vista
                </div>
            </div>

            <!-- Tooltip -->
            <div class="bp-tooltip" id="tooltip"></div>

            <!-- Loading Overlay -->
            <div class="loading-overlay" id="loadingOverlay">
                <div class="loading-spinner"></div>
            </div>
        </div>

        <!-- Right Sidebar - Properties Panel -->
        <div class="properties-panel">
            <div class="properties-header">
                <h5><i class="fas fa-sliders-h"></i> Propietats</h5>
            </div>
            <div class="properties-content" id="propertiesContent">
                <div style="text-align: center; padding: 40px 20px; color: var(--bp-text-secondary);">
                    <i class="fas fa-hand-pointer" style="font-size: 32px; margin-bottom: 10px; opacity: 0.3;"></i>
                    <p style="font-size: 12px;">Selecciona un node per veure les seves propietats</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Blueprint Editor State
        const state = {
            nodes: [],
            connections: [],
            selectedNodes: new Set(),
            selectedConnection: null,
            nodeCounter: 0,
            zoom: 1.0,
            pan: { x: 0, y: 0 },
            isPanning: false,
            isConnecting: false,
            tempConnection: null,
            draggedNode: null,
            clipboard: [],
            history: [],
            historyIndex: -1,
            lastCursorUpdate: 0,
            renderScheduled: false
        };

        // DOM Elements
        const canvas = document.getElementById('blueprintCanvas');
        const viewport = document.getElementById('canvasViewport');
        const nodesLayer = document.getElementById('nodesLayer');
        const connectionsLayer = document.getElementById('connectionsLayer');
        const propertiesContent = document.getElementById('propertiesContent');
        const emptyState = document.getElementById('emptyState');
        const contextMenu = document.getElementById('contextMenu');
        const tooltip = document.getElementById('tooltip');
        const selectionBox = document.getElementById('selectionBox');

        // Layer Definitions
        const layerDefinitions = {
            input: {
                name: 'Input Layer',
                icon: 'fa-arrow-right',
                type: 'input',
                color: '#0066cc',
                inputs: [],
                outputs: [{ name: 'out', type: 'tensor' }],
                properties: {
                    input_shape: { label: 'Input Shape', type: 'text', default: '(784,)' }
                }
            },
            linear: {
                name: 'Linear (Dense)',
                icon: 'fa-equals',
                type: 'linear',
                color: '#28a745',
                inputs: [{ name: 'in', type: 'tensor' }],
                outputs: [{ name: 'out', type: 'tensor' }],
                properties: {
                    out_features: { label: 'Output Features', type: 'number', default: 128 },
                    bias: { label: 'Use Bias', type: 'checkbox', default: true }
                }
            },
            conv2d: {
                name: 'Conv2D',
                icon: 'fa-th',
                type: 'conv',
                color: '#6f42c1',
                inputs: [{ name: 'in', type: 'tensor' }],
                outputs: [{ name: 'out', type: 'tensor' }],
                properties: {
                    out_channels: { label: 'Out Channels', type: 'number', default: 32 },
                    kernel_size: { label: 'Kernel Size', type: 'number', default: 3 },
                    stride: { label: 'Stride', type: 'number', default: 1 },
                    padding: { label: 'Padding', type: 'number', default: 1 }
                }
            },
            relu: {
                name: 'ReLU',
                icon: 'fa-chart-line',
                type: 'activation',
                color: '#ffc107',
                inputs: [{ name: 'in', type: 'tensor' }],
                outputs: [{ name: 'out', type: 'tensor' }],
                properties: {}
            },
            sigmoid: {
                name: 'Sigmoid',
                icon: 'fa-wave-square',
                type: 'activation',
                color: '#ffc107',
                inputs: [{ name: 'in', type: 'tensor' }],
                outputs: [{ name: 'out', type: 'tensor' }],
                properties: {}
            },
            maxpool2d: {
                name: 'MaxPool2D',
                icon: 'fa-compress',
                type: 'pool',
                color: '#17a2b8',
                inputs: [{ name: 'in', type: 'tensor' }],
                outputs: [{ name: 'out', type: 'tensor' }],
                properties: {
                    kernel_size: { label: 'Kernel Size', type: 'number', default: 2 },
                    stride: { label: 'Stride', type: 'number', default: 2 }
                }
            },
            batchnorm: {
                name: 'BatchNorm',
                icon: 'fa-balance-scale',
                type: 'norm',
                color: '#fd7e14',
                inputs: [{ name: 'in', type: 'tensor' }],
                outputs: [{ name: 'out', type: 'tensor' }],
                properties: {
                    num_features: { label: 'Num Features', type: 'number', default: 128 }
                }
            },
            dropout: {
                name: 'Dropout',
                icon: 'fa-random',
                type: 'dropout',
                color: '#6c757d',
                inputs: [{ name: 'in', type: 'tensor' }],
                outputs: [{ name: 'out', type: 'tensor' }],
                properties: {
                    p: { label: 'Probability', type: 'number', default: 0.5, step: 0.1 }
                }
            },
            flatten: {
                name: 'Flatten',
                icon: 'fa-stream',
                type: 'flatten',
                color: '#17a2b8',
                inputs: [{ name: 'in', type: 'tensor' }],
                outputs: [{ name: 'out', type: 'tensor' }],
                properties: {}
            },
            add: {
                name: 'Add',
                icon: 'fa-plus',
                type: 'operation',
                color: '#aa44ff',
                inputs: [
                    { name: 'in1', type: 'tensor' },
                    { name: 'in2', type: 'tensor' }
                ],
                outputs: [{ name: 'out', type: 'tensor' }],
                properties: {}
            },
            output: {
                name: 'Output Layer',
                icon: 'fa-flag-checkered',
                type: 'output',
                color: '#dc3545',
                inputs: [{ name: 'in', type: 'tensor' }],
                outputs: [],
                properties: {}
            }
        };

        // Initialize
        function init() {
            console.log('üé® Initializing Blueprint Model Designer...');
            setupEventListeners();
            updateCanvasInfo();
            console.log('‚úÖ Blueprint Designer Ready!');
        }

        // Setup Event Listeners
        function setupEventListeners() {
            // Drag and Drop from Palette
            document.querySelectorAll('.palette-item').forEach(item => {
                item.addEventListener('dragstart', handlePaletteDragStart);
            });

            canvas.addEventListener('dragover', handleCanvasDragOver);
            canvas.addEventListener('drop', handleCanvasDrop);

            // Canvas Pan
            canvas.addEventListener('mousedown', handleCanvasMouseDown);
            canvas.addEventListener('mousemove', handleCanvasMouseMove);
            canvas.addEventListener('mouseup', handleCanvasMouseUp);
            canvas.addEventListener('wheel', handleCanvasWheel);

            // Context Menu
            canvas.addEventListener('contextmenu', handleCanvasContextMenu);
            document.addEventListener('click', () => contextMenu.classList.remove('show'));

            // Toolbar Buttons
            document.getElementById('btnNew').addEventListener('click', handleNewBlueprint);
            document.getElementById('btnSave').addEventListener('click', handleSaveBlueprint);
            document.getElementById('btnUndo').addEventListener('click', handleUndo);
            document.getElementById('btnRedo').addEventListener('click', handleRedo);
            document.getElementById('btnAutoLayout').addEventListener('click', handleAutoLayout);
            document.getElementById('btnCompile').addEventListener('click', handleCompile);
            document.getElementById('btnValidate').addEventListener('click', handleValidate);

            // Zoom Controls
            document.getElementById('btnZoomIn').addEventListener('click', () => setZoom(state.zoom + 0.1));
            document.getElementById('btnZoomOut').addEventListener('click', () => setZoom(state.zoom - 0.1));
            document.getElementById('btnZoomFit').addEventListener('click', handleZoomFit);

            // Keyboard Shortcuts
            document.addEventListener('keydown', handleKeyDown);

            // Search Filter
            document.getElementById('paletteSearch').addEventListener('input', handleSearchFilter);
        }

        // Drag from Palette
        function handlePaletteDragStart(e) {
            e.dataTransfer.setData('layerType', e.target.dataset.layerType);
            e.dataTransfer.effectAllowed = 'copy';
        }

        function handleCanvasDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'copy';
        }

        function handleCanvasDrop(e) {
            e.preventDefault();
            const layerType = e.dataTransfer.getData('layerType');
            if (!layerType) return;

            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left - state.pan.x) / state.zoom;
            const y = (e.clientY - rect.top - state.pan.y) / state.zoom;

            createNode(layerType, x, y);
            emptyState.style.display = 'none';
        }

        // Create Node
        function createNode(layerType, x, y) {
            const definition = layerDefinitions[layerType];
            if (!definition) return;

            const nodeId = `node-${state.nodeCounter++}`;
            const node = {
                id: nodeId,
                type: layerType,
                definition: definition,
                position: { x, y },
                properties: {},
                inputs: [],
                outputs: []
            };

            // Initialize properties with defaults
            Object.keys(definition.properties).forEach(key => {
                node.properties[key] = definition.properties[key].default;
            });

            state.nodes.push(node);
            renderNode(node);
            updateCanvasInfo();
            console.log(`‚ú® Created node: ${definition.name} (${nodeId})`);

            return node;
        }

        // Render Node
        function renderNode(node) {
            const nodeEl = document.createElement('div');
            nodeEl.className = `bp-node type-${node.definition.type}`;
            nodeEl.id = node.id;
            nodeEl.style.left = `${node.position.x}px`;
            nodeEl.style.top = `${node.position.y}px`;

            // Header
            const header = document.createElement('div');
            header.className = 'bp-node-header';
            header.innerHTML = `
                <div class="bp-node-title">
                    <div class="bp-node-icon"><i class="fas ${node.definition.icon}"></i></div>
                    <span>${node.definition.name}</span>
                </div>
                <div class="bp-node-actions">
                    <button class="node-action-btn" data-action="duplicate"><i class="fas fa-copy"></i></button>
                    <button class="node-action-btn" data-action="delete"><i class="fas fa-trash"></i></button>
                </div>
            `;
            nodeEl.appendChild(header);

            // Body with Pins
            const body = document.createElement('div');
            body.className = 'bp-node-body';

            const pins = document.createElement('div');
            pins.className = 'bp-node-pins';

            // Render input and output pins
            const maxPins = Math.max(node.definition.inputs.length, node.definition.outputs.length);
            for (let i = 0; i < maxPins; i++) {
                const row = document.createElement('div');
                row.className = 'bp-pin-row';

                // Input pin
                if (i < node.definition.inputs.length) {
                    const input = node.definition.inputs[i];
                    const inputPin = document.createElement('div');
                    inputPin.className = 'bp-pin input';
                    inputPin.innerHTML = `
                        <div class="bp-pin-connector" data-node="${node.id}" data-pin="${input.name}" data-direction="input"></div>
                        <span class="bp-pin-label">${input.name}</span>
                    `;
                    row.appendChild(inputPin);
                } else {
                    row.appendChild(document.createElement('div'));
                }

                // Output pin
                if (i < node.definition.outputs.length) {
                    const output = node.definition.outputs[i];
                    const outputPin = document.createElement('div');
                    outputPin.className = 'bp-pin output';
                    outputPin.innerHTML = `
                        <span class="bp-pin-label">${output.name}</span>
                        <div class="bp-pin-connector" data-node="${node.id}" data-pin="${output.name}" data-direction="output"></div>
                    `;
                    row.appendChild(outputPin);
                } else {
                    row.appendChild(document.createElement('div'));
                }

                pins.appendChild(row);
            }

            body.appendChild(pins);
            nodeEl.appendChild(body);

            nodesLayer.appendChild(nodeEl);

            // Setup node interactions
            setupNodeInteractions(nodeEl, node);
        }

        // Setup Node Interactions
        function setupNodeInteractions(nodeEl, node) {
            // Node dragging
            nodeEl.addEventListener('mousedown', (e) => {
                if (e.button !== 0) return; // Only left click
                if (e.target.closest('.node-action-btn')) return; // Ignore action buttons

                state.draggedNode = node;
                nodeEl.classList.add('dragging');

                if (!e.shiftKey && !state.selectedNodes.has(node.id)) {
                    clearSelection();
                }
                selectNode(node.id);

                e.stopPropagation();
            });

            // Node selection
            nodeEl.addEventListener('click', (e) => {
                if (!e.shiftKey) clearSelection();
                selectNode(node.id);
                showNodeProperties(node);
            });

            // Pin interactions
            nodeEl.querySelectorAll('.bp-pin-connector').forEach(pin => {
                pin.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    startConnection(pin);
                });
            });

            // Action buttons
            nodeEl.querySelector('[data-action="delete"]').addEventListener('click', (e) => {
                e.stopPropagation();
                deleteNode(node.id);
            });

            nodeEl.querySelector('[data-action="duplicate"]').addEventListener('click', (e) => {
                e.stopPropagation();
                duplicateNode(node.id);
            });
        }

        // Node Selection
        function selectNode(nodeId) {
            state.selectedNodes.add(nodeId);
            document.getElementById(nodeId).classList.add('selected');
        }

        function clearSelection() {
            state.selectedNodes.forEach(id => {
                const el = document.getElementById(id);
                if (el) el.classList.remove('selected');
            });
            state.selectedNodes.clear();
        }

        // Show Node Properties
        function showNodeProperties(node) {
            const props = node.definition.properties;
            if (Object.keys(props).length === 0) {
                propertiesContent.innerHTML = `
                    <div style="text-align: center; padding: 40px 20px; color: var(--bp-text-secondary);">
                        <i class="fas fa-info-circle" style="font-size: 32px; margin-bottom: 10px; opacity: 0.3;"></i>
                        <p style="font-size: 12px;">Aquest node no t√© propietats configurables</p>
                    </div>
                `;
                return;
            }

            let html = `
                <div class="property-group">
                    <div class="property-group-title">Node: ${node.definition.name}</div>
            `;

            Object.keys(props).forEach(key => {
                const prop = props[key];
                const value = node.properties[key];

                html += `<div class="property-field">`;
                html += `<label class="property-label">${prop.label}</label>`;

                switch (prop.type) {
                    case 'number':
                        html += `<input type="number" class="property-input" data-node="${node.id}" data-property="${key}" value="${value}" step="${prop.step || 1}">`;
                        break;
                    case 'text':
                        html += `<input type="text" class="property-input" data-node="${node.id}" data-property="${key}" value="${value}">`;
                        break;
                    case 'checkbox':
                        html += `<input type="checkbox" class="property-input" data-node="${node.id}" data-property="${key}" ${value ? 'checked' : ''}>`;
                        break;
                }

                html += `</div>`;
            });

            html += `</div>`;
            propertiesContent.innerHTML = html;

            // Attach event listeners to property inputs
            propertiesContent.querySelectorAll('.property-input').forEach(input => {
                input.addEventListener('change', (e) => {
                    const nodeId = e.target.dataset.node;
                    const property = e.target.dataset.property;
                    const node = state.nodes.find(n => n.id === nodeId);

                    if (node) {
                        node.properties[property] = e.target.type === 'checkbox' ? e.target.checked : e.target.value;
                        console.log(`üîß Updated ${property} for ${nodeId}:`, node.properties[property]);
                    }
                });
            });
        }

        // Delete Node
        function deleteNode(nodeId) {
            const index = state.nodes.findIndex(n => n.id === nodeId);
            if (index === -1) return;

            // Remove connections
            state.connections = state.connections.filter(conn => {
                return conn.from.nodeId !== nodeId && conn.to.nodeId !== nodeId;
            });

            state.nodes.splice(index, 1);
            const el = document.getElementById(nodeId);
            if (el) el.remove();

            state.selectedNodes.delete(nodeId);
            updateCanvasInfo();
            renderConnections();
            console.log(`üóëÔ∏è Deleted node: ${nodeId}`);
        }

        // Duplicate Node
        function duplicateNode(nodeId) {
            const node = state.nodes.find(n => n.id === nodeId);
            if (!node) return;

            const newNode = createNode(node.type, node.position.x + 50, node.position.y + 50);
            newNode.properties = { ...node.properties };
            console.log(`üìã Duplicated node: ${nodeId} -> ${newNode.id}`);
        }

        // Canvas Pan and Zoom
        function handleCanvasMouseDown(e) {
            if (e.button === 1 || (e.button === 0 && e.target === canvas)) {
                state.isPanning = true;
                viewport.classList.add('panning');
                state.panStart = { x: e.clientX - state.pan.x, y: e.clientY - state.pan.y };
            }
        }

        function handleCanvasMouseMove(e) {
            // Throttle cursor position updates (only update every 100ms)
            if (!state.lastCursorUpdate || Date.now() - state.lastCursorUpdate > 100) {
                const rect = canvas.getBoundingClientRect();
                const x = Math.round((e.clientX - rect.left - state.pan.x) / state.zoom);
                const y = Math.round((e.clientY - rect.top - state.pan.y) / state.zoom);
                document.getElementById('cursorPos').textContent = `X: ${x}, Y: ${y}`;
                state.lastCursorUpdate = Date.now();
            }

            // Panning
            if (state.isPanning) {
                state.pan.x = e.clientX - state.panStart.x;
                state.pan.y = e.clientY - state.panStart.y;
                updateViewportTransform();
                return; // Exit early
            }

            // Node dragging
            if (state.draggedNode) {
                const deltaX = e.movementX / state.zoom;
                const deltaY = e.movementY / state.zoom;

                state.selectedNodes.forEach(nodeId => {
                    const node = state.nodes.find(n => n.id === nodeId);
                    if (node) {
                        node.position.x += deltaX;
                        node.position.y += deltaY;
                        const el = document.getElementById(nodeId);
                        if (el) {
                            el.style.left = `${node.position.x}px`;
                            el.style.top = `${node.position.y}px`;
                        }
                    }
                });

                // Use requestAnimationFrame for smooth rendering
                if (!state.renderScheduled) {
                    state.renderScheduled = true;
                    requestAnimationFrame(() => {
                        renderConnections();
                        state.renderScheduled = false;
                    });
                }
                return;
            }

            // Connection dragging
            if (state.isConnecting && state.tempConnection) {
                const rect = canvas.getBoundingClientRect();
                state.tempConnection.endX = (e.clientX - rect.left - state.pan.x) / state.zoom;
                state.tempConnection.endY = (e.clientY - rect.top - state.pan.y) / state.zoom;

                // Use requestAnimationFrame for smooth rendering
                if (!state.renderScheduled) {
                    state.renderScheduled = true;
                    requestAnimationFrame(() => {
                        renderConnections();
                        state.renderScheduled = false;
                    });
                }
            }
        }

        function handleCanvasMouseUp(e) {
            state.isPanning = false;
            viewport.classList.remove('panning');

            if (state.draggedNode) {
                state.draggedNode = null;
                document.querySelectorAll('.bp-node.dragging').forEach(el => {
                    el.classList.remove('dragging');
                });
            }

            if (state.isConnecting) {
                endConnection(e);
            }
        }

        function handleCanvasWheel(e) {
            e.preventDefault();
            const delta = e.deltaY > 0 ? -0.05 : 0.05;
            setZoom(state.zoom + delta);
        }

        function setZoom(zoom) {
            state.zoom = Math.max(0.25, Math.min(2, zoom));
            document.getElementById('zoomLevel').textContent = `${Math.round(state.zoom * 100)}%`;
            updateViewportTransform();
        }

        function updateViewportTransform() {
            viewport.style.transform = `translate(${state.pan.x}px, ${state.pan.y}px) scale(${state.zoom})`;
            renderConnections();
        }

        // Connection Management
        function startConnection(pinEl) {
            const nodeId = pinEl.dataset.node;
            const pinName = pinEl.dataset.pin;
            const direction = pinEl.dataset.direction;

            const node = state.nodes.find(n => n.id === nodeId);
            if (!node) return;

            const rect = pinEl.getBoundingClientRect();
            const canvasRect = canvas.getBoundingClientRect();

            state.isConnecting = true;
            state.tempConnection = {
                from: direction === 'output' ? { nodeId, pin: pinName } : null,
                to: direction === 'input' ? { nodeId, pin: pinName } : null,
                startX: (rect.left + rect.width / 2 - canvasRect.left - state.pan.x) / state.zoom,
                startY: (rect.top + rect.height / 2 - canvasRect.top - state.pan.y) / state.zoom,
                endX: 0,
                endY: 0,
                direction
            };

            console.log(`üîó Starting connection from ${nodeId}.${pinName}`);
        }

        function endConnection(e) {
            if (!state.tempConnection) return;

            const target = document.elementFromPoint(e.clientX, e.clientY);
            const pinEl = target?.closest('.bp-pin-connector');

            if (pinEl) {
                const targetNodeId = pinEl.dataset.node;
                const targetPin = pinEl.dataset.pin;
                const targetDirection = pinEl.dataset.direction;

                // Validate connection (output -> input)
                if (state.tempConnection.direction === 'output' && targetDirection === 'input') {
                    createConnection(state.tempConnection.from, { nodeId: targetNodeId, pin: targetPin });
                } else if (state.tempConnection.direction === 'input' && targetDirection === 'output') {
                    createConnection({ nodeId: targetNodeId, pin: targetPin }, state.tempConnection.to);
                }
            }

            state.isConnecting = false;
            state.tempConnection = null;
            renderConnections();
        }

        function createConnection(from, to) {
            // Check if connection already exists
            const exists = state.connections.some(c =>
                c.from.nodeId === from.nodeId && c.from.pin === from.pin &&
                c.to.nodeId === to.nodeId && c.to.pin === to.pin
            );

            if (exists) {
                console.log(`‚ö†Ô∏è Connection already exists`);
                return;
            }

            const connection = { from, to };
            state.connections.push(connection);
            updateCanvasInfo();
            renderConnections();
            console.log(`‚úÖ Created connection: ${from.nodeId}.${from.pin} -> ${to.nodeId}.${to.pin}`);
        }

        // Render Connections (optimized)
        function renderConnections() {
            // Cache canvas rect - only calculate once
            const canvasRect = canvas.getBoundingClientRect();

            // Use DocumentFragment for batch DOM insertion
            const fragment = document.createDocumentFragment();
            const svgNS = 'http://www.w3.org/2000/svg';

            // Clear and rebuild SVG defs
            connectionsLayer.innerHTML = '<defs><filter id="glow"><feGaussianBlur stdDeviation="2" result="coloredBlur"/><feMerge><feMergeNode in="coloredBlur"/><feMergeNode in="SourceGraphic"/></feMerge></filter></defs>';

            // Render existing connections
            state.connections.forEach(conn => {
                const fromEl = document.querySelector(`[data-node="${conn.from.nodeId}"][data-pin="${conn.from.pin}"][data-direction="output"]`);
                const toEl = document.querySelector(`[data-node="${conn.to.nodeId}"][data-pin="${conn.to.pin}"][data-direction="input"]`);
                if (!fromEl || !toEl) return;

                const fromRect = fromEl.getBoundingClientRect();
                const toRect = toEl.getBoundingClientRect();

                const x1 = (fromRect.left + fromRect.width / 2 - canvasRect.left - state.pan.x) / state.zoom;
                const y1 = (fromRect.top + fromRect.height / 2 - canvasRect.top - state.pan.y) / state.zoom;
                const x2 = (toRect.left + toRect.width / 2 - canvasRect.left - state.pan.x) / state.zoom;
                const y2 = (toRect.top + toRect.height / 2 - canvasRect.top - state.pan.y) / state.zoom;

                const path = createConnectionPath(x1, y1, x2, y2, false);
                connectionsLayer.appendChild(path);
            });

            // Render temporary connection
            if (state.tempConnection) {
                const path = createConnectionPath(
                    state.tempConnection.startX,
                    state.tempConnection.startY,
                    state.tempConnection.endX,
                    state.tempConnection.endY,
                    true
                );
                connectionsLayer.appendChild(path);
            }
        }

        // Create connection path element (extracted for reuse)
        function createConnectionPath(x1, y1, x2, y2, isTemp) {
            const dx = x2 - x1;
            const controlPointOffset = Math.min(Math.abs(dx) / 2, 100);

            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            const d = `M ${x1} ${y1} C ${x1 + controlPointOffset} ${y1}, ${x2 - controlPointOffset} ${y2}, ${x2} ${y2}`;
            path.setAttribute('d', d);
            path.setAttribute('class', isTemp ? 'bp-connection temporary' : 'bp-connection');
            path.setAttribute('filter', 'url(#glow)');

            return path;
        }

        // Toolbar Actions
        function handleNewBlueprint() {
            if (confirm('Crear nou blueprint? Es perdr√† el treball no desat.')) {
                state.nodes = [];
                state.connections = [];
                clearSelection();
                nodesLayer.innerHTML = '';
                renderConnections();
                emptyState.style.display = 'block';
                updateCanvasInfo();
                console.log('üÜï New blueprint created');
            }
        }

        function handleSaveBlueprint() {
            const blueprint = {
                nodes: state.nodes.map(n => ({
                    id: n.id,
                    type: n.type,
                    position: n.position,
                    properties: n.properties
                })),
                connections: state.connections
            };

            const json = JSON.stringify(blueprint, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'blueprint_model.json';
            a.click();

            console.log('üíæ Blueprint saved:', blueprint);
        }

        function handleAutoLayout() {
            console.log('üéØ Applying intelligent auto-layout...');

            // Separate nodes by type
            const inputNodes = state.nodes.filter(n => n.type === 'input');
            const outputNodes = state.nodes.filter(n => n.type === 'output');
            const middleNodes = state.nodes.filter(n => n.type !== 'input' && n.type !== 'output');

            // Calculate layers based on connections (topological sort)
            const layers = calculateNodeLayers();

            const LAYER_SPACING_X = 300;
            const NODE_SPACING_Y = 120;
            const START_X = 100;
            const START_Y = 150;

            // Position nodes by layers
            layers.forEach((layerNodes, layerIndex) => {
                const x = START_X + (layerIndex * LAYER_SPACING_X);

                // Center nodes vertically in each layer
                const layerHeight = (layerNodes.length - 1) * NODE_SPACING_Y;
                const startY = START_Y - (layerHeight / 2);

                layerNodes.forEach((node, nodeIndex) => {
                    node.position.x = x;
                    node.position.y = startY + (nodeIndex * NODE_SPACING_Y);

                    const el = document.getElementById(node.id);
                    if (el) {
                        el.style.left = `${node.position.x}px`;
                        el.style.top = `${node.position.y}px`;
                    }
                });
            });

            renderConnections();
            console.log(`‚úÖ Auto-layout applied: ${layers.length} layers organized`);
        }

        // Calculate node layers using topological sort
        function calculateNodeLayers() {
            const layers = [];
            const visited = new Set();
            const nodeToLayer = new Map();

            // Step 1: Find all input nodes (no incoming connections)
            const inputNodes = state.nodes.filter(node => {
                const hasIncoming = state.connections.some(c => c.to.nodeId === node.id);
                return !hasIncoming || node.type === 'input';
            });

            // Step 2: BFS to assign layers
            let currentLayer = inputNodes.map(n => n.id);
            let layerIndex = 0;

            while (currentLayer.length > 0) {
                const layerNodeObjects = currentLayer.map(id => state.nodes.find(n => n.id === id)).filter(n => n);
                layers[layerIndex] = layerNodeObjects;

                currentLayer.forEach(nodeId => {
                    visited.add(nodeId);
                    nodeToLayer.set(nodeId, layerIndex);
                });

                // Find next layer (nodes that receive from current layer)
                const nextLayer = new Set();
                currentLayer.forEach(nodeId => {
                    state.connections.forEach(conn => {
                        if (conn.from.nodeId === nodeId && !visited.has(conn.to.nodeId)) {
                            // Check if all incoming connections are visited
                            const allIncomingVisited = state.connections
                                .filter(c => c.to.nodeId === conn.to.nodeId)
                                .every(c => visited.has(c.from.nodeId));

                            if (allIncomingVisited) {
                                nextLayer.add(conn.to.nodeId);
                            }
                        }
                    });
                });

                currentLayer = Array.from(nextLayer);
                layerIndex++;

                // Safety check to prevent infinite loops
                if (layerIndex > 50) break;
            }

            // Add any disconnected nodes to the end
            const allPlacedNodes = new Set(layers.flat().map(n => n.id));
            const disconnectedNodes = state.nodes.filter(n => !allPlacedNodes.has(n.id));
            if (disconnectedNodes.length > 0) {
                layers.push(disconnectedNodes);
            }

            return layers;
        }

        function handleCompile() {
            console.log('‚öôÔ∏è Compiling model...');

            // Validation
            const errors = validateBlueprint();
            if (errors.length > 0) {
                alert(`‚ùå Errors found:\n${errors.join('\n')}`);
                return;
            }

            // Generate PyTorch model code
            const code = generatePyTorchCode();
            console.log('‚úÖ Model compiled successfully!\n\nGenerated PyTorch code:\n', code);

            alert('‚úÖ Model compilat correctament! Revisa la consola per veure el codi generat.');
        }

        function handleValidate() {
            console.log('üîç Validating blueprint...');
            const errors = validateBlueprint();

            if (errors.length === 0) {
                alert('‚úÖ El blueprint √©s v√†lid!');
                console.log('‚úÖ Blueprint is valid');
            } else {
                alert(`‚ùå S'han trobat ${errors.length} errors:\n\n${errors.join('\n')}`);
                console.error('‚ùå Validation errors:', errors);
            }
        }

        function validateBlueprint() {
            const errors = [];

            // Check for at least one input and output
            const hasInput = state.nodes.some(n => n.type === 'input');
            const hasOutput = state.nodes.some(n => n.type === 'output');

            if (!hasInput) errors.push('- No hi ha cap capa d\'entrada');
            if (!hasOutput) errors.push('- No hi ha cap capa de sortida');

            // Check for disconnected nodes (except input)
            state.nodes.forEach(node => {
                if (node.type === 'input') return;

                const hasIncoming = state.connections.some(c => c.to.nodeId === node.id);
                if (!hasIncoming) {
                    errors.push(`- Node desconnectat: ${node.definition.name} (${node.id})`);
                }
            });

            return errors;
        }

        function generatePyTorchCode() {
            let code = 'import torch\nimport torch.nn as nn\n\nclass GeneratedModel(nn.Module):\n    def __init__(self):\n        super().__init__()\n';

            // Generate layer definitions
            state.nodes.forEach(node => {
                if (node.type === 'input' || node.type === 'output') return;

                code += `        self.${node.id} = `;

                switch (node.type) {
                    case 'linear':
                        code += `nn.Linear(?, ${node.properties.out_features || 128})\n`;
                        break;
                    case 'conv2d':
                        code += `nn.Conv2d(?, ${node.properties.out_channels || 32}, kernel_size=${node.properties.kernel_size || 3})\n`;
                        break;
                    case 'relu':
                        code += `nn.ReLU()\n`;
                        break;
                    case 'dropout':
                        code += `nn.Dropout(p=${node.properties.p || 0.5})\n`;
                        break;
                    // Add more layer types...
                    default:
                        code += `# ${node.definition.name}\n`;
                }
            });

            code += '\n    def forward(self, x):\n';
            code += '        # TODO: Implement forward pass based on connections\n';
            code += '        return x\n';

            return code;
        }

        function handleUndo() {
            console.log('‚Ü∂ Undo');
            // TODO: Implement undo functionality
        }

        function handleRedo() {
            console.log('‚Ü∑ Redo');
            // TODO: Implement redo functionality
        }

        function handleZoomFit() {
            // Reset zoom and pan to fit all nodes
            state.zoom = 1.0;
            state.pan = { x: 0, y: 0 };
            updateViewportTransform();
            document.getElementById('zoomLevel').textContent = '100%';
        }

        function handleCanvasContextMenu(e) {
            e.preventDefault();
            contextMenu.style.left = `${e.clientX}px`;
            contextMenu.style.top = `${e.clientY}px`;
            contextMenu.classList.add('show');
        }

        function handleKeyDown(e) {
            // Delete selected nodes
            if (e.key === 'Delete' || e.key === 'Backspace') {
                state.selectedNodes.forEach(nodeId => deleteNode(nodeId));
            }

            // Copy
            if (e.ctrlKey && e.key === 'c') {
                state.clipboard = Array.from(state.selectedNodes);
                console.log('üìã Copied nodes:', state.clipboard);
            }

            // Paste
            if (e.ctrlKey && e.key === 'v') {
                state.clipboard.forEach(nodeId => {
                    const node = state.nodes.find(n => n.id === nodeId);
                    if (node) duplicateNode(nodeId);
                });
            }

            // Select All
            if (e.ctrlKey && e.key === 'a') {
                e.preventDefault();
                clearSelection();
                state.nodes.forEach(n => selectNode(n.id));
            }

            // Undo/Redo
            if (e.ctrlKey && e.key === 'z') handleUndo();
            if (e.ctrlKey && e.key === 'y') handleRedo();
        }

        function handleSearchFilter(e) {
            const query = e.target.value.toLowerCase();
            document.querySelectorAll('.palette-item').forEach(item => {
                const text = item.textContent.toLowerCase();
                item.style.display = text.includes(query) ? 'block' : 'none';
            });
        }

        // Update Canvas Info
        function updateCanvasInfo() {
            document.getElementById('nodeCount').textContent = `${state.nodes.length} nodes`;
            document.getElementById('connectionCount').textContent = `${state.connections.length} connexions`;
        }

        // Initialize on load
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
