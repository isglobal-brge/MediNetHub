<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MediNet - Model Designer (Bug Fixed)</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        /* Header y Navigation */
        .medinet-header {
            background: linear-gradient(135deg, #2563eb, #1d4ed8);
            color: white;
            padding: 0.75rem 0;
        }
        
        .nav-tabs {
            background: rgba(255,255,255,0.1);
            border-radius: 50px;
            padding: 0.5rem;
        }
        
        .nav-tabs .nav-link {
            color: rgba(255,255,255,0.7);
            border: none;
            border-radius: 40px;
            margin: 0 0.25rem;
            transition: all 0.3s ease;
        }
        
        .nav-tabs .nav-link.active {
            background: rgba(255,255,255,0.2);
            color: white;
            font-weight: 600;
        }
        
        /* Page Header */
        .page-header {
            background: white;
            border-bottom: 1px solid #e5e7eb;
            padding: 1.5rem 0;
        }
        
        .page-title {
            color: #1f2937;
            font-weight: 700;
            font-size: 1.5rem;
            margin: 0;
        }
        
        .page-subtitle {
            color: #6b7280;
            font-size: 0.875rem;
            margin: 0;
        }
        
        /* Action Buttons */
        .action-buttons {
            gap: 0.5rem;
        }
        
        .btn-action {
            border-radius: 8px;
            font-weight: 500;
            padding: 0.625rem 1.25rem;
            transition: all 0.2s ease;
            border: none;
        }
        
        .btn-action:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        
        .btn-load { background: #f3f4f6; color: #374151; }
        .btn-preview { background: #fef3c7; color: #92400e; }
        .btn-save { background: #374151; color: white; }
        .btn-training { background: #059669; color: white; }
        
        /* Main Layout */
        .designer-layout {
            display: grid;
            grid-template-columns: 320px 1fr 320px;
            gap: 1rem;
            height: calc(100vh - 180px);
            padding: 1rem;
            background: #f9fafb;
        }
        
        /* Panel Styles */
        .designer-panel {
            background: white;
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .panel-header {
            background: #f8fafc;
            border-bottom: 1px solid #e5e7eb;
            padding: 1rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        
        .panel-title {
            font-weight: 600;
            color: #1f2937;
            margin: 0;
        }
        
        .panel-icon {
            width: 20px;
            height: 20px;
            color: #6b7280;
        }
        
        .panel-body {
            flex: 1;
            padding: 1rem;
            overflow-y: auto;
        }
        
        /* Node Canvas - Centro del dise√±o */
        .node-canvas {
            position: relative;
            background: 
                linear-gradient(90deg, #f1f5f9 1px, transparent 1px), 
                linear-gradient(#f1f5f9 1px, transparent 1px);
            background-size: 24px 24px;
            border-radius: 8px;
            flex: 1;
            overflow: hidden;
            margin: 1rem;
            transition: background-color 0.2s ease;
        }
        
        .node-canvas.dragging-active {
            background-color: rgba(59, 130, 246, 0.02);
            background-image: 
                linear-gradient(90deg, rgba(59, 130, 246, 0.3) 1px, transparent 1px), 
                linear-gradient(rgba(59, 130, 246, 0.3) 1px, transparent 1px);
        }

        /* COMPONENT: Node Layer Styles */
        .layer-node {
            position: absolute;
            width: 150px;
            height: 80px;
            background: white;
            border-radius: 10px;
            border: 2px solid #e5e7eb;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 14px;
            cursor: grab;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            user-select: none;
            transform: none !important;
        }
        
        .layer-node:hover {
            border-color: #3b82f6;
            transform: scale(1.02);
            z-index: 10;
            box-shadow: 0 4px 20px rgba(59, 130, 246, 0.15);
        }
        
        .layer-node.selected {
            border-color: #2563eb;
            box-shadow: 0 0 0 4px rgba(37, 99, 235, 0.15);
            z-index: 5;
        }
        
        .layer-node.dragging {
            transform: scale(1.05);
            z-index: 50;
            box-shadow: 0 12px 40px rgba(0,0,0,0.3);
            cursor: grabbing;
            opacity: 0.9;
            transition: none;
        }
        
        .layer-node:active {
            cursor: grabbing;
        }

        .layer-node.node-input {
            border: 3px solid #3b82f6 !important;
            background: linear-gradient(145deg, #dbeafe, #bfdbfe) !important;
            box-shadow: 0 4px 20px rgba(59, 130, 246, 0.2);
        }
        
        .layer-node.node-output {
            border: 3px solid #ef4444 !important;
            background: linear-gradient(145deg, #fee2e2, #fecaca) !important;
            box-shadow: 0 4px 20px rgba(239, 68, 68, 0.2);
        }
        
        .layer-node.node-input.dragging,
        .layer-node.node-output.dragging {
            z-index: 1000;
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
            transform: scale(1.05);
        }
        
        /* Node Type Variations */
        .layer-node.layer-input { 
            border-left: 4px solid #3b82f6; 
            background: linear-gradient(145deg, #ffffff, #f8faff);
        }
        .layer-node.layer-linear { 
            border-left: 4px solid #10b981; 
            background: linear-gradient(145deg, #ffffff, #f0fdf9);
        }
        .layer-node.layer-activation { 
            border-left: 4px solid #f59e0b; 
            background: linear-gradient(145deg, #ffffff, #fffbeb);
        }
        .layer-node.layer-output { 
            border-left: 4px solid #ef4444; 
            background: linear-gradient(145deg, #ffffff, #fef2f2);
        }
        .layer-node.layer-operation { 
            border-left: 4px solid #8b5cf6; 
            background: linear-gradient(145deg, #ffffff, #faf5ff);
        }
        
        .node-content {
            flex: 1;
            text-align: center;
        }
        
        .node-title {
            font-size: 13px;
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 3px;
        }
        
        .node-features {
            font-size: 11px;
            color: #6b7280;
        }

        /* COMPONENT: Connection Port Styles */
        .connection-port {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            border: 2px solid #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            z-index: 20;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .connection-port:hover {
            transform: scale(1.4);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        
        .connection-port.input { 
            background: #10b981; 
        }
        .connection-port.output { 
            background: #ef4444; 
        }
        
        .connection-port.left-side { 
            position: absolute; 
            left: -7px; 
            top: 50%; 
            transform: translateY(-50%);
        }
        .connection-port.right-side { 
            position: absolute; 
            right: -7px; 
            top: 50%; 
            transform: translateY(-50%);
        }
        
        .connection-port.smart-port {
            background: #94a3b8;
            border: 3px solid #fff;
            transition: all 0.3s ease;
        }
        
        .connection-port.smart-port:hover {
            background: #3b82f6;
            transform: translateY(-50%) scale(1.4);
        }
        
        .connection-port.smart-port.acting-as-input {
            background: #10b981;
        }
        
        .connection-port.smart-port.acting-as-output {
            background: #ef4444;
        }
        
        .connection-port.smart-port.connecting {
            background: #3b82f6 !important;
            border-color: #1d4ed8;
            animation: pulse-connect 1s infinite;
        }
        
        .connection-port.disconnected {
            background: #94a3b8 !important;
            border-color: #cbd5e1;
            animation: pulse-disconnect 2s infinite;
        }
        
        @keyframes pulse-disconnect {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        @keyframes pulse-connect {
            0%, 100% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.7); }
            50% { box-shadow: 0 0 0 6px rgba(59, 130, 246, 0); }
        }

        /* COMPONENT: Connection/Arrow Styles */
        .connection-path {
            stroke: #6b7280;
            stroke-width: 2.5;
            fill: none;
            stroke-dasharray: 8, 4;
            animation: dash-flow 3s linear infinite;
            filter: drop-shadow(0 1px 2px rgba(0,0,0,0.1));
            cursor: pointer;
            pointer-events: all;
            transition: all 0.2s ease;
        }
        
        .connection-path.flow-highlight {
            stroke: #3b82f6;
            stroke-width: 3.5;
            stroke-dasharray: 12, 6;
            filter: drop-shadow(0 2px 8px rgba(59, 130, 246, 0.4));
            animation: flow-highlight 2s linear infinite;
        }
        
        @keyframes flow-highlight {
            0% { stroke-dashoffset: 0; }
            100% { stroke-dashoffset: -18; }
        }
        
        .connection-path:hover {
            stroke: #ef4444;
            stroke-width: 4;
            stroke-dasharray: none;
            animation: none;
            filter: drop-shadow(0 2px 8px rgba(239, 68, 68, 0.3));
        }
        
        .connection-path.deleting {
            stroke: #dc2626;
            stroke-width: 5;
            stroke-dasharray: 4, 4;
            animation: delete-pulse 0.5s ease-in-out infinite alternate;
        }
        
        .connection-path.connection-selected {
            stroke: #fbbf24 !important;
            stroke-width: 4;
            filter: drop-shadow(0 2px 8px rgba(251, 191, 36, 0.5));
            animation: none;
        }
        
        @keyframes dash-flow {
            to { stroke-dashoffset: -12; }
        }
        
        @keyframes delete-pulse {
            from { opacity: 1; }
            to { opacity: 0.3; }
        }
        
        .connection-preview {
            stroke: #3b82f6;
            stroke-width: 3;
            fill: none;
            stroke-dasharray: 8, 8;
            animation: preview-flow 1s linear infinite;
            opacity: 0.8;
            pointer-events: none;
        }
        
        @keyframes preview-flow {
            to { stroke-dashoffset: 16; }
        }

        /* Configuration Panel */
        .form-group {
            margin-bottom: 1.25rem;
        }
        
        .form-label {
            display: block;
            font-weight: 500;
            color: #374151;
            margin-bottom: 0.5rem;
            font-size: 0.875rem;
        }
        
        .form-control, .form-select {
            border: 1px solid #d1d5db;
            border-radius: 6px;
            padding: 0.5rem 0.75rem;
            font-size: 0.875rem;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }
        
        .form-control:focus, .form-select:focus {
            border-color: #2563eb;
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
            outline: none;
        }
        
        .optimizer-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.75rem;
        }

        .param-section {
            margin-bottom: 1.5rem;
        }
        
        .param-section-title {
            font-size: 0.875rem;
            font-weight: 600;
            color: #374151;
            margin-bottom: 0.75rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid #f3f4f6;
        }
        
        .param-row {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 0.75rem;
        }
        
        .param-row label {
            min-width: 80px;
            font-size: 0.8125rem;
            color: #6b7280;
        }
        
        .param-row input {
            flex: 1;
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
        }
        
        .delete-btn {
            width: 100%;
            background: #fee2e2;
            color: #dc2626;
            border: 1px solid #fecaca;
            border-radius: 6px;
            padding: 0.5rem;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .delete-btn:hover {
            background: #fecaca;
            border-color: #fca5a5;
        }

        .add-node-btn {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            border: 2px dashed #cbd5e1;
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            color: #64748b;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        
        .add-node-btn:hover {
            border-color: #3b82f6;
            color: #3b82f6;
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(59, 130, 246, 0.15);
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 0.5rem;
        }
        
        .status-active { background: #10b981; }
        .status-inactive { background: #6b7280; }
        .status-error { background: #ef4444; }

        @media (max-width: 1200px) {
            .designer-layout {
                grid-template-columns: 280px 1fr 280px;
            }
        }
        
        @media (max-width: 992px) {
            .designer-layout {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto 1fr;
                height: auto;
            }
            
            .designer-panel {
                max-height: 400px;
            }
            
            .node-canvas {
                min-height: 400px;
            }
        }
    </style>
</head>
<body>
    <!-- Header Navigation -->
    <header class="medinet-header">
        <div class="container">
            <div class="d-flex justify-content-between align-items-center">
                <div class="d-flex align-items-center">
                    <h4 class="text-white mb-0 me-4">
                        <i class="fas fa-brain me-2"></i>
                        MediNet
                    </h4>
                    
                    <ul class="nav nav-tabs border-0">
                        <li class="nav-item">
                            <a class="nav-link" href="#">
                                <i class="fas fa-database me-1"></i>
                                Panel
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="#">
                                <i class="fas fa-chart-bar me-1"></i>
                                Datasets
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link active" href="#">
                                <i class="fas fa-project-diagram me-1"></i>
                                Model Studio
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="#">
                                <i class="fas fa-cogs me-1"></i>
                                Training
                            </a>
                        </li>
                    </ul>
                </div>
                
                <div class="d-flex align-items-center text-white">
                    <i class="fas fa-bell me-3"></i>
                    <div class="dropdown">
                        <span class="dropdown-toggle" data-bs-toggle="dropdown">
                            <i class="fas fa-user-circle me-1"></i>
                            admin
                        </span>
                    </div>
                </div>
            </div>
        </div>
    </header>

    <!-- Page Header -->
    <div class="page-header">
        <div class="container">
            <div class="row align-items-center">
                <div class="col-md-6">
                    <h1 class="page-title">
                        <i class="fas fa-project-diagram me-2 text-primary"></i>
                        Model Designer <span class="badge bg-danger">Bug Fixed</span>
                    </h1>
                    <p class="page-subtitle">
                        Fixed connection deletion and memory leaks
                    </p>
                </div>
                <div class="col-md-6">
                    <div class="d-flex justify-content-md-end action-buttons">
                        <button class="btn btn-action btn-load">
                            <i class="fas fa-folder-open me-1"></i>
                            Load Model
                        </button>
                        <button class="btn btn-action btn-preview">
                            <i class="fas fa-code me-1"></i>
                            Preview JSON
                        </button>
                        <button class="btn btn-action btn-save">
                            <i class="fas fa-save me-1"></i>
                            Save Model
                        </button>
                        <button class="btn btn-action btn-training">
                            <i class="fas fa-play me-1"></i>
                            Go to Training
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Designer Layout -->
    <div class="designer-layout">
        <!-- Configuration Panel (Left) -->
        <div class="designer-panel">
            <div class="panel-header">
                <i class="fas fa-cog panel-icon"></i>
                <h6 class="panel-title">Configuration</h6>
            </div>
            <div class="panel-body">
                <!-- Model Basic Info -->
                <div class="form-group">
                    <label class="form-label">Model Name</label>
                    <input type="text" class="form-control" value="My Neural Network" placeholder="Enter model name">
                </div>
                
                <div class="form-group">
                    <label class="form-label">Framework</label>
                    <select class="form-select">
                        <option selected>PyTorch</option>
                        <option>TensorFlow</option>
                        <option>Keras</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label class="form-label">Description</label>
                    <textarea class="form-control" rows="3" placeholder="Model description..."></textarea>
                </div>
                
                <!-- Optimizer Configuration -->
                <div class="form-group">
                    <label class="form-label">Optimizer</label>
                    <select class="form-select">
                        <option selected>Adam</option>
                        <option>SGD</option>
                        <option>RMSprop</option>
                        <option>AdaGrad</option>
                    </select>
                </div>
                
                <div class="optimizer-grid">
                    <div>
                        <label class="form-label">Learning Rate</label>
                        <input type="number" class="form-control" value="0.001" step="0.0001">
                    </div>
                    <div>
                        <label class="form-label">Weight Decay</label>
                        <input type="number" class="form-control" value="0" step="0.0001">
                    </div>
                </div>
                
                <!-- Loss Function -->
                <div class="form-group">
                    <label class="form-label">Loss Function</label>
                    <select class="form-select">
                        <option selected>Binary Cross Entropy with Logits</option>
                        <option>Cross Entropy</option>
                        <option>Mean Squared Error</option>
                        <option>Mean Absolute Error</option>
                    </select>
                </div>
                
                <!-- Model Status -->
                <div class="mt-4 p-3 bg-light rounded">
                    <h6 class="mb-2">Model Status</h6>
                    <div class="d-flex align-items-center mb-2">
                        <span class="status-indicator status-active"></span>
                        <small>Ready for training</small>
                    </div>
                    <div class="d-flex justify-content-between">
                        <small class="text-muted">Layers: 5</small>
                        <small class="text-muted">Parameters: ~2.1K</small>
                    </div>
                </div>
            </div>
        </div>

        <!-- Node Canvas (Center) -->
        <div class="designer-panel">
            <div class="panel-header">
                <i class="fas fa-sitemap panel-icon"></i>
                <h6 class="panel-title">Neural Network Graph</h6>
                <div class="ms-auto">
                    <button class="btn btn-sm btn-outline-primary me-2" id="autoLayoutBtn">
                        <i class="fas fa-magic me-1"></i>
                        Auto Layout
                    </button>
                    <button class="btn btn-sm btn-outline-secondary" id="resetViewBtn">
                        <i class="fas fa-undo me-1"></i>
                        Reset View
                    </button>
                </div>
            </div>
            
            <div class="node-canvas" id="nodeCanvas">
                <!-- COMPONENT: SVG Connection System -->
                <svg id="connectionsSvg" style="position: absolute; width: 100%; height: 100%; z-index: 1; pointer-events: none;">
                    <!-- Connections will be drawn dynamically -->
                </svg>
                
                <!-- COMPONENT: Input Node -->
                <div class="layer-node layer-input node-input selected" data-node-id="input" style="left: 50px; top: 200px;">
                    <div class="node-content">
                        <div class="node-title">Input</div>
                        <div class="node-features">12 features</div>
                    </div>
                    <div class="connection-port smart-port right-side acting-as-output disconnected" 
                         data-port-type="output" data-side="right" data-preferred="output"></div>
                </div>
                
                <!-- COMPONENT: Output Node -->
                <div class="layer-node layer-output node-output" data-node-id="output" style="left: 600px; top: 200px;">
                    <div class="connection-port smart-port left-side acting-as-input disconnected" 
                         data-port-type="input" data-side="left" data-preferred="input"></div>
                    <div class="node-content">
                        <div class="node-title">Output</div>
                        <div class="node-features">1 feature</div>
                    </div>
                </div>
                
                <!-- COMPONENT: Add Layer Button -->
                <div class="add-node-btn" id="addLayerBtn" data-bs-toggle="tooltip" title="Add Layer">
                    <i class="fas fa-plus fa-lg"></i>
                </div>
                
                <!-- COMPONENT: Connection Helper -->
                <svg id="connectionHelper" style="position: absolute; width: 100%; height: 100%; z-index: 15; pointer-events: none; display: none;">
                    <path id="helperPath" class="connection-preview"/>
                </svg>
            </div>
        </div>

        <!-- Layer Parameters Panel (Right) -->
        <div class="designer-panel">
            <div class="panel-header">
                <i class="fas fa-sliders-h panel-icon"></i>
                <h6 class="panel-title">Layer Parameters</h6>
            </div>
            <div class="panel-body">
                <div class="param-section">
                    <div class="param-section-title">Linear Parameters</div>
                    
                    <div class="param-row">
                        <label>In Features</label>
                        <input type="number" class="form-control" value="64">
                    </div>
                    
                    <div class="param-row">
                        <label>Out Features</label>
                        <input type="number" class="form-control" value="64">
                    </div>
                    
                    <div class="checkbox-group">
                        <input type="checkbox" id="use-bias" checked>
                        <label for="use-bias" class="form-check-label">
                            Use Bias
                        </label>
                    </div>
                </div>
                
                <div class="param-section">
                    <div class="param-section-title">Advanced Settings</div>
                    
                    <div class="param-row">
                        <label>Device</label>
                        <select class="form-select form-select-sm">
                            <option>Auto</option>
                            <option>CPU</option>
                            <option>CUDA</option>
                        </select>
                    </div>
                    
                    <div class="param-row">
                        <label>Dtype</label>
                        <select class="form-select form-select-sm">
                            <option>float32</option>
                            <option>float16</option>
                            <option>float64</option>
                        </select>
                    </div>
                </div>
                
                <div class="param-section">
                    <div class="param-section-title">Initialization</div>
                    
                    <div class="param-row">
                        <label>Weight Init</label>
                        <select class="form-select form-select-sm">
                            <option>Xavier Uniform</option>
                            <option>Xavier Normal</option>
                            <option>He Uniform</option>
                            <option>He Normal</option>
                            <option>Random</option>
                        </select>
                    </div>
                    
                    <div class="param-row">
                        <label>Bias Init</label>
                        <select class="form-select form-select-sm">
                            <option>Zero</option>
                            <option>Random</option>
                            <option>Constant</option>
                        </select>
                    </div>
                </div>
                
                <!-- Action Buttons -->
                <div class="mt-4">
                    <button class="btn btn-primary btn-sm w-100 mb-2">
                        <i class="fas fa-check me-1"></i>
                        Apply Changes
                    </button>
                    <button class="delete-btn" id="deleteNodeBtn">
                        <i class="fas fa-trash me-1"></i>
                        Delete Layer
                    </button>
                </div>
                
                <!-- Layer Info -->
                <div class="mt-4 p-3 bg-light rounded">
                    <h6 class="mb-2">Layer Information</h6>
                    <div class="d-flex justify-content-between mb-1">
                        <small class="text-muted">Parameters:</small>
                        <small>4,160</small>
                    </div>
                    <div class="d-flex justify-content-between mb-1">
                        <small class="text-muted">Memory:</small>
                        <small>~16.6 KB</small>
                    </div>
                    <div class="d-flex justify-content-between">
                        <small class="text-muted">FLOPs:</small>
                        <small>4,096</small>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    
    <script>
        // ============================================================================
        // BUG FIXED MODEL DESIGNER - COMPREHENSIVE CLEANUP SYSTEM
        // ============================================================================
        console.log('üêõ Initializing Bug Fixed Model Designer...');
        
        // ============================================================================
        // ENHANCED STATE MANAGEMENT WITH CLEANUP TRACKING
        // ============================================================================
        
        class ModelDesignerState {
            constructor() {
                this.nodes = new Map();
                this.connections = new Map();
                this.nodeCounter = 0;
                this.isConnecting = false;
                this.connectingFrom = null;
                this.isDragging = false;
                this.dragNode = null;
                this.dragOffset = { x: 0, y: 0 };
                
                // üêõ FIX: Add tracking for cleanup
                this.eventListeners = new Set();
                this.svgElements = new Set();
                this.modalInstances = new Set();
                
                console.log('üìä Enhanced state management initialized with cleanup tracking');
            }
            
            reset() {
                this.isConnecting = false;
                this.connectingFrom = null;
                this.isDragging = false;
                this.dragNode = null;
                this.dragOffset = { x: 0, y: 0 };
                console.log('üîÑ State reset');
            }
            
            // üêõ FIX: Add comprehensive cleanup method
            cleanup() {
                console.log('üßπ Performing comprehensive cleanup...');
                
                // Clear event listeners
                this.eventListeners.forEach(cleanup => cleanup());
                this.eventListeners.clear();
                
                // Clear SVG elements
                this.svgElements.forEach(element => {
                    if (element.parentNode) {
                        element.parentNode.removeChild(element);
                    }
                });
                this.svgElements.clear();
                
                // Clear modal instances
                this.modalInstances.forEach(modal => {
                    modal.dispose();
                });
                this.modalInstances.clear();
                
                console.log('‚úÖ Cleanup completed');
            }
        }
        
        // ============================================================================
        // ENHANCED LAYER NODE COMPONENT WITH ROBUST CLEANUP
        // ============================================================================
        
        class LayerNodeComponent {
            constructor(canvas, state, connectionComponent) {
                this.canvas = canvas;
                this.state = state;
                this.connectionComponent = connectionComponent; // üêõ FIX: Add reference to connection component
                this.GRID_SIZE = 24;
                this.SNAP_THRESHOLD = 12;
                
                this.layerTypes = {
                    linear: { name: 'Linear', color: '#10b981', defaultFeatures: 64 },
                    relu: { name: 'ReLU', color: '#f59e0b', defaultFeatures: 'same' },
                    sigmoid: { name: 'Sigmoid', color: '#f59e0b', defaultFeatures: 'same' },
                    tanh: { name: 'Tanh', color: '#f59e0b', defaultFeatures: 'same' },
                    dropout: { name: 'Dropout', color: '#8b5cf6', defaultFeatures: 'same' },
                    batchnorm: { name: 'BatchNorm', color: '#6366f1', defaultFeatures: 'same' },
                    conv2d: { name: 'Conv2D', color: '#06b6d4', defaultFeatures: 32 }
                };
                
                console.log('üß© Enhanced Layer Node Component initialized');
            }
            
            createNode(layerType) {
                const typeConfig = this.layerTypes[layerType];
                const nodeId = `layer-${++this.state.nodeCounter}`;
                
                const position = this.calculateSmartPosition();
                
                const nodeHTML = `
                    <div class="layer-node layer-${layerType}" data-node-id="${nodeId}" 
                         style="left: ${position.x}px; top: ${position.y}px;">
                        
                        <!-- Left smart port -->
                        <div class="connection-port smart-port left-side disconnected" 
                             data-port-type="smart" data-side="left" data-preferred="input"></div>
                        
                        <!-- Node content -->
                        <div class="node-content">
                            <div class="node-title">${typeConfig.name}</div>
                            <div class="node-features">${typeConfig.defaultFeatures} features</div>
                        </div>
                        
                        <!-- Right smart port -->
                        <div class="connection-port smart-port right-side disconnected" 
                             data-port-type="smart" data-side="right" data-preferred="output"></div>
                        
                    </div>
                `;
                
                this.canvas.insertAdjacentHTML('beforeend', nodeHTML);
                
                // Store node data
                this.state.nodes.set(nodeId, {
                    type: layerType,
                    features: typeConfig.defaultFeatures,
                    x: position.x, 
                    y: position.y
                });
                
                console.log(`‚ûï Created ${typeConfig.name} layer at (${position.x}, ${position.y})`);
                
                // Auto-select the new node
                const newNode = document.querySelector(`[data-node-id="${nodeId}"]`);
                this.selectNode(newNode);
                
                return newNode;
            }
            
            // üêõ CRITICAL FIX: Comprehensive node deletion with connection cleanup
            deleteNode(nodeId) {
                const node = document.querySelector(`[data-node-id="${nodeId}"]`);
                if (!node || nodeId === 'input' || nodeId === 'output') {
                    console.log('‚ö†Ô∏è Cannot delete Input/Output nodes');
                    return false;
                }
                
                console.log(`üóëÔ∏è Starting comprehensive deletion of node: ${nodeId}`);
                
                // üêõ FIX: STEP 1 - Find and delete ALL connections involving this node
                const connectionsToDelete = [];
                this.state.connections.forEach((connection, connectionId) => {
                    if (connection.from === nodeId || connection.to === nodeId) {
                        connectionsToDelete.push(connectionId);
                        console.log(`üîó Found connection to delete: ${connectionId}`);
                    }
                });
                
                // üêõ FIX: STEP 2 - Delete each connection properly
                connectionsToDelete.forEach(connectionId => {
                    this.connectionComponent.deleteConnection(connectionId);
                    console.log(`‚úÖ Deleted connection: ${connectionId}`);
                });
                
                // üêõ FIX: STEP 3 - Clean up port states before node removal
                const ports = node.querySelectorAll('.connection-port');
                ports.forEach(port => {
                    port.classList.remove('connecting', 'acting-as-input', 'acting-as-output');
                    port.classList.add('disconnected');
                });
                
                // üêõ FIX: STEP 4 - Remove node with proper cleanup
                node.style.transition = 'all 0.3s ease';
                node.style.opacity = '0';
                node.style.transform = 'scale(0.8)';
                
                setTimeout(() => {
                    // Final cleanup
                    node.remove();
                    this.state.nodes.delete(nodeId);
                    
                    // üêõ FIX: STEP 5 - Update flow highlighting after deletion
                    setTimeout(() => {
                        this.connectionComponent.updateFlowHighlighting();
                    }, 50);
                    
                    // üêõ FIX: STEP 6 - Select Input node as fallback
                    const inputNode = document.querySelector('.node-input');
                    if (inputNode) {
                        this.selectNode(inputNode);
                    }
                    
                    console.log(`‚úÖ Node ${nodeId} completely deleted with all connections`);
                }, 300);
                
                return true;
            }
            
            calculateSmartPosition() {
                const canvasRect = this.canvas.getBoundingClientRect();
                const existingNodes = this.canvas.querySelectorAll('.layer-node[data-node-id]:not([data-node-id="input"]):not([data-node-id="output"])');
                
                // Default position (center)
                let x = this.snapToGrid((canvasRect.width / 2) - 75);
                let y = this.snapToGrid((canvasRect.height / 2) - 40);
                
                if (existingNodes.length === 0) {
                    // First layer - position between input and output
                    x = this.snapToGrid(canvasRect.width * 0.4);
                    y = this.snapToGrid((canvasRect.height / 2) - 40);
                } else {
                    // Find a free spot using spiral pattern
                    const occupiedPositions = new Set();
                    existingNodes.forEach(node => {
                        const nodeX = parseInt(node.style.left);
                        const nodeY = parseInt(node.style.top);
                        occupiedPositions.add(`${nodeX},${nodeY}`);
                    });
                    
                    const centerX = this.snapToGrid((canvasRect.width / 2) - 75);
                    const centerY = this.snapToGrid((canvasRect.height / 2) - 40);
                    
                    for (let radius = 0; radius < 200; radius += this.GRID_SIZE) {
                        for (let angle = 0; angle < 360; angle += 45) {
                            const testX = this.snapToGrid(centerX + radius * Math.cos(angle * Math.PI / 180));
                            const testY = this.snapToGrid(centerY + radius * Math.sin(angle * Math.PI / 180));
                            
                            if (testX >= 0 && testX <= canvasRect.width - 150 && 
                                testY >= 0 && testY <= canvasRect.height - 80) {
                                
                                if (!occupiedPositions.has(`${testX},${testY}`)) {
                                    return { x: testX, y: testY };
                                }
                            }
                        }
                    }
                }
                
                return { x, y };
            }
            
            snapToGrid(value) {
                return Math.round(value / this.GRID_SIZE) * this.GRID_SIZE;
            }
            
            selectNode(node) {
                // Remove selected class from all nodes
                document.querySelectorAll('.layer-node').forEach(n => n.classList.remove('selected'));
                // Add selected class to target node
                node.classList.add('selected');
                
                console.log('üéØ Node selected:', node.querySelector('.node-title').textContent);
            }
        }
        
        // ============================================================================
        // ENHANCED CONNECTION COMPONENT WITH ROBUST ERROR HANDLING
        // ============================================================================
        
        class ConnectionComponent {
            constructor(canvas, state) {
                this.canvas = canvas;
                this.state = state;
                this.svg = document.getElementById('connectionsSvg');
                this.helperSvg = document.getElementById('connectionHelper');
                this.helperPath = document.getElementById('helperPath');
                
                console.log('üîó Enhanced Connection Component initialized');
            }
            
            startConnection(e, port) {
                // üêõ FIX: Add error handling
                try {
                    const nodeElement = port.closest('.layer-node');
                    if (!nodeElement) {
                        console.error('‚ùå Port is not associated with a node');
                        return;
                    }
                    
                    const nodeId = nodeElement.dataset.nodeId;
                    
                    // Smart port determines its role as OUTPUT when starting connection
                    this.determineSmartPortRole(port, 'output');
                    
                    this.state.isConnecting = true;
                    this.state.connectingFrom = { 
                        port, 
                        nodeId, 
                        portType: 'output',
                        startX: e.clientX,
                        startY: e.clientY
                    };
                    
                    port.classList.add('connecting');
                    
                    // Show connection helper
                    this.helperSvg.style.display = 'block';
                    
                    console.log('üîó Started connection from:', nodeId);
                } catch (error) {
                    console.error('‚ùå Error starting connection:', error);
                    this.state.reset();
                }
            }
            
            updateConnection(e) {
                if (!this.state.isConnecting || !this.state.connectingFrom) return;
                
                // üêõ FIX: Add error handling for canvas calculations
                try {
                    const canvasRect = this.canvas.getBoundingClientRect();
                    const fromRect = this.state.connectingFrom.port.getBoundingClientRect();
                    
                    // Calculate positions relative to canvas
                    const fromX = fromRect.left - canvasRect.left + fromRect.width / 2;
                    const fromY = fromRect.top - canvasRect.top + fromRect.height / 2;
                    const toX = e.clientX - canvasRect.left;
                    const toY = e.clientY - canvasRect.top;
                    
                    // Update preview path
                    const midX = (fromX + toX) / 2;
                    const pathData = `M ${fromX} ${fromY} Q ${midX} ${fromY}, ${midX} ${(fromY + toY) / 2} Q ${midX} ${toY}, ${toX} ${toY}`;
                    
                    this.helperPath.setAttribute('d', pathData);
                } catch (error) {
                    console.error('‚ùå Error updating connection preview:', error);
                }
            }
            
            completeConnection(toPort) {
                // üêõ FIX: Add comprehensive error handling
                try {
                    const fromPort = this.state.connectingFrom.port;
                    const fromNodeElement = fromPort.closest('.layer-node');
                    const toNodeElement = toPort.closest('.layer-node');
                    
                    if (!fromNodeElement || !toNodeElement) {
                        console.error('‚ùå Cannot find node elements for connection');
                        this.cancelConnection();
                        return;
                    }
                    
                    const fromNodeId = fromNodeElement.dataset.nodeId;
                    const toNodeId = toNodeElement.dataset.nodeId;
                    
                    // üêõ FIX: Prevent self-connections
                    if (fromNodeId === toNodeId) {
                        console.log('‚ö†Ô∏è Cannot connect node to itself');
                        this.cancelConnection();
                        return;
                    }
                    
                    // üêõ FIX: Prevent duplicate connections
                    const connectionId = `${fromNodeId}-${toNodeId}`;
                    if (this.state.connections.has(connectionId)) {
                        console.log('‚ö†Ô∏è Connection already exists');
                        this.cancelConnection();
                        return;
                    }
                    
                    // Smart port determines its role as INPUT when completing connection
                    this.determineSmartPortRole(toPort, 'input');
                    
                    // Create connection
                    this.state.connections.set(connectionId, {
                        from: fromNodeId,
                        to: toNodeId,
                        fromPort,
                        toPort
                    });
                    
                    // Update port states
                    fromPort.classList.remove('connecting', 'disconnected');
                    toPort.classList.remove('disconnected');
                    
                    // Draw connection line
                    this.drawConnection(fromPort, toPort, connectionId);
                    
                    // Hide preview
                    this.helperSvg.style.display = 'none';
                    
                    console.log('‚úÖ Connection created:', fromNodeId, '‚Üí', toNodeId);
                    
                    // Update flow highlighting
                    setTimeout(() => this.updateFlowHighlighting(), 100);
                    
                    // Reset connection state
                    this.state.reset();
                } catch (error) {
                    console.error('‚ùå Error completing connection:', error);
                    this.cancelConnection();
                }
            }
            
            cancelConnection() {
                try {
                    if (this.state.connectingFrom) {
                        this.state.connectingFrom.port.classList.remove('connecting');
                        this.state.connectingFrom.port.classList.add('disconnected');
                    }
                    
                    // Hide preview
                    this.helperSvg.style.display = 'none';
                    
                    this.state.reset();
                    console.log('‚ùå Connection cancelled');
                } catch (error) {
                    console.error('‚ùå Error cancelling connection:', error);
                    this.state.reset();
                }
            }
            
            drawConnection(fromPort, toPort, connectionId) {
                try {
                    const fromRect = fromPort.getBoundingClientRect();
                    const toRect = toPort.getBoundingClientRect();
                    const canvasRect = this.canvas.getBoundingClientRect();
                    
                    // Calculate relative positions
                    const fromX = fromRect.left - canvasRect.left + fromRect.width / 2;
                    const fromY = fromRect.top - canvasRect.top + fromRect.height / 2;
                    const toX = toRect.left - canvasRect.left + toRect.width / 2;
                    const toY = toRect.top - canvasRect.top + toRect.height / 2;
                    
                    // Create path element
                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    const midX = (fromX + toX) / 2;
                    const pathData = `M ${fromX} ${fromY} Q ${midX} ${fromY}, ${midX} ${(fromY + toY) / 2} Q ${midX} ${toY}, ${toX} ${toY}`;
                    
                    path.setAttribute('d', pathData);
                    path.setAttribute('class', 'connection-path');
                    if (connectionId) {
                        path.dataset.connectionId = connectionId;
                    }
                    
                    // üêõ FIX: Track SVG elements for cleanup
                    this.state.svgElements.add(path);
                    
                    this.svg.appendChild(path);
                    return path;
                } catch (error) {
                    console.error('‚ùå Error drawing connection:', error);
                    return null;
                }
            }
            
            // üêõ FIX: Enhanced connection deletion with proper cleanup
            deleteConnection(connectionId) {
                try {
                    const connection = this.state.connections.get(connectionId);
                    const pathElement = document.querySelector(`[data-connection-id="${connectionId}"]`);
                    
                    if (!connection) {
                        console.warn(`‚ö†Ô∏è Connection ${connectionId} not found in state`);
                        return;
                    }
                    
                    if (pathElement) {
                        pathElement.classList.add('deleting');
                        
                        setTimeout(() => {
                            try {
                                // Remove from state
                                this.state.connections.delete(connectionId);
                                
                                // Remove SVG element
                                pathElement.remove();
                                this.state.svgElements.delete(pathElement);
                                
                                // üêõ FIX: Safe port state updates with null checks
                                if (connection.fromPort) {
                                    connection.fromPort.classList.add('disconnected');
                                    connection.fromPort.classList.remove('acting-as-output');
                                }
                                if (connection.toPort) {
                                    connection.toPort.classList.add('disconnected');
                                    connection.toPort.classList.remove('acting-as-input');
                                }
                                
                                console.log('üóëÔ∏è Connection deleted:', connectionId);
                                
                                // Update flow highlighting
                                setTimeout(() => this.updateFlowHighlighting(), 100);
                            } catch (error) {
                                console.error('‚ùå Error in connection deletion cleanup:', error);
                            }
                        }, 500);
                    } else {
                        // üêõ FIX: Handle case where path element doesn't exist
                        console.warn(`‚ö†Ô∏è Path element for connection ${connectionId} not found, cleaning state only`);
                        this.state.connections.delete(connectionId);
                    }
                } catch (error) {
                    console.error('‚ùå Error deleting connection:', error);
                }
            }
            
            redrawAllConnections() {
                try {
                    // Clear all SVG elements
                    this.svg.innerHTML = '';
                    this.state.svgElements.clear();
                    
                    this.state.connections.forEach((connection, id) => {
                        this.drawConnection(connection.fromPort, connection.toPort, id);
                    });
                    
                    console.log('üîÑ All connections redrawn');
                } catch (error) {
                    console.error('‚ùå Error redrawing connections:', error);
                }
            }
            
            determineSmartPortRole(port, role) {
                try {
                    const isSmart = port.classList.contains('smart-port');
                    if (!isSmart) return role;
                    
                    const preferred = port.dataset.preferred;
                    const side = port.dataset.side;
                    
                    port.classList.add(`acting-as-${role}`);
                    port.classList.remove(`acting-as-${role === 'input' ? 'output' : 'input'}`);
                    port.dataset.portType = role;
                    
                    console.log(`üß† Smart port (${side}) adapting as ${role.toUpperCase()}`);
                    return role;
                } catch (error) {
                    console.error('‚ùå Error determining smart port role:', error);
                    return role;
                }
            }
            
            updateFlowHighlighting() {
                try {
                    // Remove existing highlights
                    document.querySelectorAll('.connection-path').forEach(path => {
                        path.classList.remove('flow-highlight');
                    });
                    
                    // Find all paths from Input node
                    const inputNodeId = 'input';
                    const flowPaths = new Set();
                    
                    const traceFlow = (nodeId, visited = new Set()) => {
                        if (visited.has(nodeId)) return;
                        visited.add(nodeId);
                        
                        this.state.connections.forEach((connection, connectionId) => {
                            if (connection.from === nodeId) {
                                flowPaths.add(connectionId);
                                traceFlow(connection.to, visited);
                            }
                        });
                    };
                    
                    traceFlow(inputNodeId);
                    
                    // Apply highlighting
                    flowPaths.forEach(connectionId => {
                        const pathElement = document.querySelector(`[data-connection-id="${connectionId}"]`);
                        if (pathElement) {
                            pathElement.classList.add('flow-highlight');
                        }
                    });
                    
                    console.log(`‚ú® Flow highlighting updated - ${flowPaths.size} connections highlighted`);
                } catch (error) {
                    console.error('‚ùå Error updating flow highlighting:', error);
                }
            }
        }
        
        // ============================================================================
        // ENHANCED DRAG DROP COMPONENT WITH ERROR RECOVERY
        // ============================================================================
        
        class DragDropComponent {
            constructor(canvas, state, connectionComponent) {
                this.canvas = canvas;
                this.state = state;
                this.connectionComponent = connectionComponent;
                this.GRID_SIZE = 24;
                
                console.log('üñ±Ô∏è Enhanced Drag Drop Component initialized');
            }
            
            startDragging(e, node) {
                try {
                    this.state.isDragging = true;
                    this.state.dragNode = node;
                    
                    const nodeRect = node.getBoundingClientRect();
                    const canvasRect = this.canvas.getBoundingClientRect();
                    
                    // Calculate mouse position relative to the canvas
                    const mouseCanvasX = e.clientX - canvasRect.left;
                    const mouseCanvasY = e.clientY - canvasRect.top;
                    
                    // Calculate node position relative to the canvas
                    const nodeCanvasX = nodeRect.left - canvasRect.left;
                    const nodeCanvasY = nodeRect.top - canvasRect.top;
                    
                    // Calculate offset from mouse to node's top-left corner
                    this.state.dragOffset = {
                        x: mouseCanvasX - nodeCanvasX,
                        y: mouseCanvasY - nodeCanvasY
                    };
                    
                    node.classList.add('dragging');
                    this.canvas.classList.add('dragging-active');
                    
                    console.log('üñ±Ô∏è Started dragging:', node.dataset.nodeId);
                } catch (error) {
                    console.error('‚ùå Error starting drag:', error);
                    this.state.reset();
                }
            }
            
            updateDragging(e) {
                if (!this.state.dragNode) return;
                
                try {
                    const canvasRect = this.canvas.getBoundingClientRect();
                    
                    // Calculate new position based on mouse and offset
                    const mouseCanvasX = e.clientX - canvasRect.left;
                    const mouseCanvasY = e.clientY - canvasRect.top;
                    
                    let x = mouseCanvasX - this.state.dragOffset.x;
                    let y = mouseCanvasY - this.state.dragOffset.y;
                    
                    // Snap to grid
                    x = this.snapToGrid(x);
                    y = this.snapToGrid(y);
                    
                    // Constrain to canvas bounds
                    const nodeWidth = 150;
                    const nodeHeight = 80;
                    x = Math.max(0, Math.min(x, canvasRect.width - nodeWidth));
                    y = Math.max(0, Math.min(y, canvasRect.height - nodeHeight));
                    
                    // Update node position
                    this.state.dragNode.style.left = x + 'px';
                    this.state.dragNode.style.top = y + 'px';
                    
                    // Update stored position
                    const nodeId = this.state.dragNode.dataset.nodeId;
                    if (this.state.nodes.has(nodeId)) {
                        this.state.nodes.get(nodeId).x = x;
                        this.state.nodes.get(nodeId).y = y;
                    }
                    
                    // Redraw connections in real-time
                    this.connectionComponent.redrawAllConnections();
                } catch (error) {
                    console.error('‚ùå Error updating drag:', error);
                }
            }
            
            stopDragging() {
                try {
                    if (this.state.dragNode) {
                        this.state.dragNode.classList.remove('dragging');
                        this.canvas.classList.remove('dragging-active');
                        
                        // Final snap to grid position
                        const finalX = this.snapToGrid(parseInt(this.state.dragNode.style.left));
                        const finalY = this.snapToGrid(parseInt(this.state.dragNode.style.top));
                        
                        this.state.dragNode.style.left = finalX + 'px';
                        this.state.dragNode.style.top = finalY + 'px';
                        
                        // Update stored position
                        const nodeId = this.state.dragNode.dataset.nodeId;
                        if (this.state.nodes.has(nodeId)) {
                            this.state.nodes.get(nodeId).x = finalX;
                            this.state.nodes.get(nodeId).y = finalY;
                        }
                        
                        // Final connection redraw
                        this.connectionComponent.redrawAllConnections();
                        
                        console.log('üñ±Ô∏è Stopped dragging:', this.state.dragNode.dataset.nodeId);
                    }
                    
                    this.state.reset();
                } catch (error) {
                    console.error('‚ùå Error stopping drag:', error);
                    this.state.reset();
                }
            }
            
            snapToGrid(value) {
                return Math.round(value / this.GRID_SIZE) * this.GRID_SIZE;
            }
        }
        
        // ============================================================================
        // MAIN APPLICATION CONTROLLER WITH COMPREHENSIVE ERROR HANDLING
        // ============================================================================
        
        class ModelDesignerApp {
            constructor() {
                try {
                    this.canvas = document.getElementById('nodeCanvas');
                    this.state = new ModelDesignerState();
                    
                    // Initialize components with cross-references
                    this.connectionComponent = new ConnectionComponent(this.canvas, this.state);
                    this.layerComponent = new LayerNodeComponent(this.canvas, this.state, this.connectionComponent);
                    this.dragDropComponent = new DragDropComponent(this.canvas, this.state, this.connectionComponent);
                    
                    this.initializeEventListeners();
                    this.initializeCanvas();
                    
                    // üêõ FIX: Add error recovery system
                    window.addEventListener('error', (e) => {
                        console.error('üö® Global error caught:', e.error);
                        this.recoverFromError();
                    });
                    
                    console.log('üöÄ Enhanced Model Designer App initialized successfully');
                } catch (error) {
                    console.error('‚ùå Fatal error initializing app:', error);
                }
            }
            
            // üêõ FIX: Add error recovery system
            recoverFromError() {
                console.log('üîß Attempting error recovery...');
                
                try {
                    // Reset state
                    this.state.reset();
                    
                    // Clear any stuck UI states
                    document.querySelectorAll('.layer-node').forEach(node => {
                        node.classList.remove('dragging');
                    });
                    this.canvas.classList.remove('dragging-active');
                    
                    // Hide connection helper
                    const helperSvg = document.getElementById('connectionHelper');
                    if (helperSvg) {
                        helperSvg.style.display = 'none';
                    }
                    
                    console.log('‚úÖ Error recovery completed');
                } catch (recoveryError) {
                    console.error('‚ùå Error recovery failed:', recoveryError);
                }
            }
            
            initializeCanvas() {
                try {
                    // Set initial port states as disconnected
                    document.querySelectorAll('.connection-port').forEach(port => {
                        port.classList.add('disconnected');
                    });
                    
                    console.log('üé® Canvas initialized');
                } catch (error) {
                    console.error('‚ùå Error initializing canvas:', error);
                }
            }
            
            initializeEventListeners() {
                try {
                    // Mouse down handler - priority system
                    const mouseDownHandler = (e) => {
                        try {
                            // Priority 1: Connection ports
                            const port = e.target.closest('.connection-port');
                            if (port && !this.state.isDragging) {
                                if (port.classList.contains('smart-port') || port.classList.contains('output')) {
                                    this.connectionComponent.startConnection(e, port);
                                }
                                e.preventDefault();
                                return;
                            }
                            
                            // Priority 2: Node dragging
                            const node = e.target.closest('.layer-node');
                            if (node && !e.target.closest('.connection-port') && !this.state.isConnecting) {
                                this.dragDropComponent.startDragging(e, node);
                            }
                        } catch (error) {
                            console.error('‚ùå Error in mousedown handler:', error);
                        }
                    };
                    
                    // Mouse move handler
                    const mouseMoveHandler = (e) => {
                        try {
                            if (this.state.isConnecting && this.state.connectingFrom) {
                                this.connectionComponent.updateConnection(e);
                            } else if (this.state.isDragging && this.state.dragNode) {
                                this.dragDropComponent.updateDragging(e);
                            }
                        } catch (error) {
                            console.error('‚ùå Error in mousemove handler:', error);
                        }
                    };
                    
                    // Mouse up handler
                    const mouseUpHandler = (e) => {
                        try {
                            if (this.state.isConnecting) {
                                const port = e.target.closest('.connection-port');
                                if (port && (port.classList.contains('smart-port') || port.classList.contains('input'))) {
                                    this.connectionComponent.completeConnection(port);
                                } else {
                                    this.connectionComponent.cancelConnection();
                                }
                            } else if (this.state.isDragging) {
                                this.dragDropComponent.stopDragging();
                            }
                        } catch (error) {
                            console.error('‚ùå Error in mouseup handler:', error);
                        }
                    };
                    
                    // Node selection
                    const nodeClickHandler = (e) => {
                        try {
                            if (e.target.closest('.layer-node')) {
                                const node = e.target.closest('.layer-node');
                                this.layerComponent.selectNode(node);
                            }
                        } catch (error) {
                            console.error('‚ùå Error in node selection:', error);
                        }
                    };
                    
                    // Connection management
                    const connectionClickHandler = (e) => {
                        try {
                            if (e.target.classList.contains('connection-path')) {
                                if (e.ctrlKey || e.metaKey) {
                                    const connectionId = e.target.dataset.connectionId;
                                    this.connectionComponent.deleteConnection(connectionId);
                                }
                            }
                        } catch (error) {
                            console.error('‚ùå Error in connection click:', error);
                        }
                    };
                    
                    // Keyboard shortcuts
                    const keyboardHandler = (e) => {
                        try {
                            if (e.key === 'Delete' || e.key === 'Backspace') {
                                e.preventDefault();
                                const selectedNode = document.querySelector('.layer-node.selected');
                                if (selectedNode) {
                                    this.layerComponent.deleteNode(selectedNode.dataset.nodeId);
                                }
                            } else if (e.key === 'Escape') {
                                if (this.state.isConnecting) {
                                    this.connectionComponent.cancelConnection();
                                }
                            }
                        } catch (error) {
                            console.error('‚ùå Error in keyboard handler:', error);
                        }
                    };
                    
                    // üêõ FIX: Track event listeners for cleanup
                    document.addEventListener('mousedown', mouseDownHandler);
                    document.addEventListener('mousemove', mouseMoveHandler);
                    document.addEventListener('mouseup', mouseUpHandler);
                    document.addEventListener('click', nodeClickHandler);
                    document.addEventListener('click', connectionClickHandler);
                    document.addEventListener('keydown', keyboardHandler);
                    
                    // Store cleanup functions
                    this.state.eventListeners.add(() => document.removeEventListener('mousedown', mouseDownHandler));
                    this.state.eventListeners.add(() => document.removeEventListener('mousemove', mouseMoveHandler));
                    this.state.eventListeners.add(() => document.removeEventListener('mouseup', mouseUpHandler));
                    this.state.eventListeners.add(() => document.removeEventListener('click', nodeClickHandler));
                    this.state.eventListeners.add(() => document.removeEventListener('click', connectionClickHandler));
                    this.state.eventListeners.add(() => document.removeEventListener('keydown', keyboardHandler));
                    
                    // Add layer button
                    const addLayerBtn = document.getElementById('addLayerBtn');
                    if (addLayerBtn) {
                        const addLayerHandler = () => this.showLayerTypeModal();
                        addLayerBtn.addEventListener('click', addLayerHandler);
                        this.state.eventListeners.add(() => addLayerBtn.removeEventListener('click', addLayerHandler));
                    }
                    
                    // Auto layout button
                    const autoLayoutBtn = document.getElementById('autoLayoutBtn');
                    if (autoLayoutBtn) {
                        const autoLayoutHandler = () => this.autoArrangeNodes();
                        autoLayoutBtn.addEventListener('click', autoLayoutHandler);
                        this.state.eventListeners.add(() => autoLayoutBtn.removeEventListener('click', autoLayoutHandler));
                    }
                    
                    console.log('üéõÔ∏è Enhanced event listeners initialized');
                } catch (error) {
                    console.error('‚ùå Error initializing event listeners:', error);
                }
            }
            
            showLayerTypeModal() {
                try {
                    const modalHTML = `
                        <div class="modal fade" id="layerTypeModal" tabindex="-1">
                            <div class="modal-dialog modal-dialog-centered">
                                <div class="modal-content">
                                    <div class="modal-header">
                                        <h5 class="modal-title">
                                            <i class="fas fa-layer-group me-2"></i>
                                            Select Layer Type
                                        </h5>
                                        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                                    </div>
                                    <div class="modal-body">
                                        <div class="row g-3">
                                            ${Object.entries(this.layerComponent.layerTypes).map(([key, type]) => `
                                                <div class="col-6">
                                                    <div class="layer-type-card" data-layer-type="${key}" 
                                                         style="border: 2px solid #e5e7eb; border-radius: 8px; padding: 1rem; 
                                                                text-align: center; cursor: pointer; transition: all 0.2s ease;">
                                                        <div style="width: 40px; height: 40px; border-radius: 50%; 
                                                                   margin: 0 auto 0.5rem; background: ${type.color};"></div>
                                                        <div style="font-weight: 600; color: #374151;">${type.name}</div>
                                                    </div>
                                                </div>
                                            `).join('')}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                    
                    // Remove existing modal
                    const existingModal = document.getElementById('layerTypeModal');
                    if (existingModal) existingModal.remove();
                    
                    // Add modal to DOM
                    document.body.insertAdjacentHTML('beforeend', modalHTML);
                    
                    // Show modal
                    const modal = new bootstrap.Modal(document.getElementById('layerTypeModal'));
                    modal.show();
                    
                    // üêõ FIX: Track modal for cleanup
                    this.state.modalInstances.add(modal);
                    
                    // Handle layer type selection
                    document.querySelectorAll('.layer-type-card').forEach(card => {
                        const cardClickHandler = () => {
                            const layerType = card.dataset.layerType;
                            this.layerComponent.createNode(layerType);
                            modal.hide();
                        };
                        card.addEventListener('click', cardClickHandler);
                        
                        // Hover effects
                        const hoverInHandler = () => {
                            card.style.borderColor = '#3b82f6';
                            card.style.transform = 'translateY(-2px)';
                        };
                        const hoverOutHandler = () => {
                            card.style.borderColor = '#e5e7eb';
                            card.style.transform = 'translateY(0)';
                        };
                        
                        card.addEventListener('mouseenter', hoverInHandler);
                        card.addEventListener('mouseleave', hoverOutHandler);
                    });
                    
                    console.log('üé≠ Enhanced layer type modal opened');
                } catch (error) {
                    console.error('‚ùå Error showing layer type modal:', error);
                }
            }
            
            autoArrangeNodes() {
                try {
                    const allNodes = this.canvas.querySelectorAll('.layer-node[data-node-id]:not([data-node-id="input"]):not([data-node-id="output"])');
                    const canvasRect = this.canvas.getBoundingClientRect();
                    
                    if (allNodes.length === 0) return;
                    
                    // Calculate positions for horizontal arrangement
                    const startX = 200;
                    const endX = canvasRect.width - 250;
                    const spacing = allNodes.length > 1 ? (endX - startX) / (allNodes.length - 1) : 0;
                    const centerY = canvasRect.height / 2 - 40;
                    
                    allNodes.forEach((node, index) => {
                        const x = startX + (index * spacing);
                        node.style.left = x + 'px';
                        node.style.top = centerY + 'px';
                        
                        // Update stored position
                        const nodeId = node.dataset.nodeId;
                        if (this.state.nodes.has(nodeId)) {
                            this.state.nodes.get(nodeId).x = x;
                            this.state.nodes.get(nodeId).y = centerY;
                        }
                    });
                    
                    // Redraw all connections
                    this.connectionComponent.redrawAllConnections();
                    
                    console.log('‚ú® Auto layout applied');
                } catch (error) {
                    console.error('‚ùå Error in auto arrange:', error);
                }
            }
            
            // üêõ FIX: Add cleanup method for app destruction
            destroy() {
                console.log('üí• Destroying Model Designer App...');
                this.state.cleanup();
            }
        }
        
        // ============================================================================
        // APPLICATION INITIALIZATION WITH ERROR RECOVERY
        // ============================================================================
        
        // Initialize tooltips
        const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'))
        const tooltipList = tooltipTriggerList.map(function (tooltipTriggerEl) {
            return new bootstrap.Tooltip(tooltipTriggerEl)
        });
        
        // Initialize the application when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            try {
                window.modelDesignerApp = new ModelDesignerApp();
                
                console.log('');
                console.log('üêõ BUG FIXES IMPLEMENTED:');
                console.log('   ‚úÖ CRITICAL: Connection deletion when nodes are removed');
                console.log('   ‚úÖ Memory leak prevention with proper cleanup');
                console.log('   ‚úÖ SVG element orphan prevention');
                console.log('   ‚úÖ Port state consistency maintenance');
                console.log('   ‚úÖ Error recovery and graceful degradation');
                console.log('   ‚úÖ Event listener cleanup tracking');
                console.log('   ‚úÖ Modal instance cleanup');
                console.log('   ‚úÖ Flow highlighting updates after deletion');
                console.log('');
                console.log('üîß ENHANCED FEATURES:');
                console.log('   ‚Ä¢ Comprehensive error handling throughout');
                console.log('   ‚Ä¢ Self-healing error recovery system');
                console.log('   ‚Ä¢ Memory leak prevention');
                console.log('   ‚Ä¢ Robust state management');
                console.log('   ‚Ä¢ Enhanced debugging and logging');
                console.log('');
                console.log('üìù TESTING INSTRUCTIONS:');
                console.log('   1. Create nodes and connections');
                console.log('   2. Delete a connected node (connections should disappear)');
                console.log('   3. Verify no orphaned SVG elements remain');
                console.log('   4. Check browser memory usage remains stable');
                console.log('   5. Test error recovery by causing intentional errors');
            } catch (error) {
                console.error('‚ùå Critical error during initialization:', error);
                
                // Fallback initialization
                setTimeout(() => {
                    console.log('üîß Attempting fallback initialization...');
                    try {
                        window.modelDesignerApp = new ModelDesignerApp();
                    } catch (fallbackError) {
                        console.error('‚ùå Fallback initialization failed:', fallbackError);
                    }
                }, 1000);
            }
        });
    </script>
</body>
</html>